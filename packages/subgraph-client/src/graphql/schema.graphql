# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type InitializedEvent {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    transactionHash: Bytes!
    version: Int!
}

type OwnershipTransferredEvent {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    newOwner: Bytes!
    previousOwner: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    initializedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): InitializedEvent
    initializedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: InitializedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: InitializedEvent_filter
    ): [InitializedEvent!]!
    ownershipTransferredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferredEvent
    ownershipTransferredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferredEvent_filter
    ): [OwnershipTransferredEvent!]!
    registeredTypeEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegisteredTypeEvent
    registeredTypeEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RegisteredTypeEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RegisteredTypeEvent_filter
    ): [RegisteredTypeEvent!]!
    rewrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewrappedEvent
    rewrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewrappedEvent_filter
    ): [RewrappedEvent!]!
    unwrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UnwrappedEvent
    unwrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UnwrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UnwrappedEvent_filter
    ): [UnwrappedEvent!]!
    unwrappedPartiallyEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UnwrappedPartiallyEvent
    unwrappedPartiallyEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UnwrappedPartiallyEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UnwrappedPartiallyEvent_filter
    ): [UnwrappedPartiallyEvent!]!
    wrappedBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedBalance
    wrappedBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WrappedBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WrappedBalance_filter
    ): [WrappedBalance!]!
    wrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedEvent
    wrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WrappedEvent_filter
    ): [WrappedEvent!]!
}

type RegisteredTypeEvent {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    tokenType: BigInt!
    transactionHash: Bytes!
}

type RewrappedEvent {
    amount: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    metaNftId: BigInt!
    newRestrictionId: BigInt!
    oldRestrictionId: BigInt!
    token: Bytes!
    tokenType: BigInt!
    transactionHash: Bytes!
    unlockTimestamp: BigInt!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    initializedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): InitializedEvent
    initializedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: InitializedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: InitializedEvent_filter
    ): [InitializedEvent!]!
    ownershipTransferredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OwnershipTransferredEvent
    ownershipTransferredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OwnershipTransferredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OwnershipTransferredEvent_filter
    ): [OwnershipTransferredEvent!]!
    registeredTypeEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RegisteredTypeEvent
    registeredTypeEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RegisteredTypeEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RegisteredTypeEvent_filter
    ): [RegisteredTypeEvent!]!
    rewrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewrappedEvent
    rewrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewrappedEvent_filter
    ): [RewrappedEvent!]!
    unwrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UnwrappedEvent
    unwrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UnwrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UnwrappedEvent_filter
    ): [UnwrappedEvent!]!
    unwrappedPartiallyEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UnwrappedPartiallyEvent
    unwrappedPartiallyEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UnwrappedPartiallyEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UnwrappedPartiallyEvent_filter
    ): [UnwrappedPartiallyEvent!]!
    wrappedBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedBalance
    wrappedBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WrappedBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WrappedBalance_filter
    ): [WrappedBalance!]!
    wrappedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WrappedEvent
    wrappedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WrappedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WrappedEvent_filter
    ): [WrappedEvent!]!
}

type UnwrappedEvent {
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    metaNftId: BigInt!
    oldRestrictionId: BigInt!
    token: Bytes!
    tokenType: BigInt!
    transactionHash: Bytes!
}

type UnwrappedPartiallyEvent {
    account: Bytes!
    amountPercentage: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    metaNftId: BigInt!
    newRestrictionId: BigInt!
    nftTokenID: BigInt!
    oldRestrictionId: BigInt!
    token: Bytes!
    tokenType: BigInt!
    transactionHash: Bytes!
}

type WrappedBalance {
    amount: BigInt!
    id: ID!
    metaNftId: BigInt!
    nftTokenID: BigInt!
    restrictionId: BigInt!
    token: Bytes!
    tokenType: BigInt!
    unlockTimestamp: BigInt!
}

type WrappedEvent {
    amount: BigInt!
    blockNumber: BigInt!
    blockTimestamp: BigInt!
    id: ID!
    metaNftId: BigInt!
    nftTokenID: BigInt!
    restrictionId: BigInt!
    token: Bytes!
    tokenType: BigInt!
    transactionHash: Bytes!
    unlockTimestamp: BigInt!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum InitializedEvent_orderBy {
    blockNumber
    blockTimestamp
    id
    transactionHash
    version
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum OwnershipTransferredEvent_orderBy {
    blockNumber
    blockTimestamp
    id
    newOwner
    previousOwner
    transactionHash
}

enum RegisteredTypeEvent_orderBy {
    blockNumber
    blockTimestamp
    id
    tokenType
    transactionHash
}

enum RewrappedEvent_orderBy {
    amount
    blockNumber
    blockTimestamp
    id
    metaNftId
    newRestrictionId
    oldRestrictionId
    token
    tokenType
    transactionHash
    unlockTimestamp
}

enum UnwrappedEvent_orderBy {
    blockNumber
    blockTimestamp
    id
    metaNftId
    oldRestrictionId
    token
    tokenType
    transactionHash
}

enum UnwrappedPartiallyEvent_orderBy {
    account
    amountPercentage
    blockNumber
    blockTimestamp
    id
    metaNftId
    newRestrictionId
    nftTokenID
    oldRestrictionId
    token
    tokenType
    transactionHash
}

enum WrappedBalance_orderBy {
    amount
    id
    metaNftId
    nftTokenID
    restrictionId
    token
    tokenType
    unlockTimestamp
}

enum WrappedEvent_orderBy {
    amount
    blockNumber
    blockTimestamp
    id
    metaNftId
    nftTokenID
    restrictionId
    token
    tokenType
    transactionHash
    unlockTimestamp
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input InitializedEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    version: Int
    version_gt: Int
    version_gte: Int
    version_in: [Int!]
    version_lt: Int
    version_lte: Int
    version_not: Int
    version_not_in: [Int!]
}

input OwnershipTransferredEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    newOwner: Bytes
    newOwner_contains: Bytes
    newOwner_in: [Bytes!]
    newOwner_not: Bytes
    newOwner_not_contains: Bytes
    newOwner_not_in: [Bytes!]
    previousOwner: Bytes
    previousOwner_contains: Bytes
    previousOwner_in: [Bytes!]
    previousOwner_not: Bytes
    previousOwner_not_contains: Bytes
    previousOwner_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RegisteredTypeEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RewrappedEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metaNftId: BigInt
    metaNftId_gt: BigInt
    metaNftId_gte: BigInt
    metaNftId_in: [BigInt!]
    metaNftId_lt: BigInt
    metaNftId_lte: BigInt
    metaNftId_not: BigInt
    metaNftId_not_in: [BigInt!]
    newRestrictionId: BigInt
    newRestrictionId_gt: BigInt
    newRestrictionId_gte: BigInt
    newRestrictionId_in: [BigInt!]
    newRestrictionId_lt: BigInt
    newRestrictionId_lte: BigInt
    newRestrictionId_not: BigInt
    newRestrictionId_not_in: [BigInt!]
    oldRestrictionId: BigInt
    oldRestrictionId_gt: BigInt
    oldRestrictionId_gte: BigInt
    oldRestrictionId_in: [BigInt!]
    oldRestrictionId_lt: BigInt
    oldRestrictionId_lte: BigInt
    oldRestrictionId_not: BigInt
    oldRestrictionId_not_in: [BigInt!]
    token: Bytes
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    unlockTimestamp: BigInt
    unlockTimestamp_gt: BigInt
    unlockTimestamp_gte: BigInt
    unlockTimestamp_in: [BigInt!]
    unlockTimestamp_lt: BigInt
    unlockTimestamp_lte: BigInt
    unlockTimestamp_not: BigInt
    unlockTimestamp_not_in: [BigInt!]
}

input UnwrappedEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metaNftId: BigInt
    metaNftId_gt: BigInt
    metaNftId_gte: BigInt
    metaNftId_in: [BigInt!]
    metaNftId_lt: BigInt
    metaNftId_lte: BigInt
    metaNftId_not: BigInt
    metaNftId_not_in: [BigInt!]
    oldRestrictionId: BigInt
    oldRestrictionId_gt: BigInt
    oldRestrictionId_gte: BigInt
    oldRestrictionId_in: [BigInt!]
    oldRestrictionId_lt: BigInt
    oldRestrictionId_lte: BigInt
    oldRestrictionId_not: BigInt
    oldRestrictionId_not_in: [BigInt!]
    token: Bytes
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input UnwrappedPartiallyEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    amountPercentage: BigInt
    amountPercentage_gt: BigInt
    amountPercentage_gte: BigInt
    amountPercentage_in: [BigInt!]
    amountPercentage_lt: BigInt
    amountPercentage_lte: BigInt
    amountPercentage_not: BigInt
    amountPercentage_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metaNftId: BigInt
    metaNftId_gt: BigInt
    metaNftId_gte: BigInt
    metaNftId_in: [BigInt!]
    metaNftId_lt: BigInt
    metaNftId_lte: BigInt
    metaNftId_not: BigInt
    metaNftId_not_in: [BigInt!]
    newRestrictionId: BigInt
    newRestrictionId_gt: BigInt
    newRestrictionId_gte: BigInt
    newRestrictionId_in: [BigInt!]
    newRestrictionId_lt: BigInt
    newRestrictionId_lte: BigInt
    newRestrictionId_not: BigInt
    newRestrictionId_not_in: [BigInt!]
    nftTokenID: BigInt
    nftTokenID_gt: BigInt
    nftTokenID_gte: BigInt
    nftTokenID_in: [BigInt!]
    nftTokenID_lt: BigInt
    nftTokenID_lte: BigInt
    nftTokenID_not: BigInt
    nftTokenID_not_in: [BigInt!]
    oldRestrictionId: BigInt
    oldRestrictionId_gt: BigInt
    oldRestrictionId_gte: BigInt
    oldRestrictionId_in: [BigInt!]
    oldRestrictionId_lt: BigInt
    oldRestrictionId_lte: BigInt
    oldRestrictionId_not: BigInt
    oldRestrictionId_not_in: [BigInt!]
    token: Bytes
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input WrappedBalance_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metaNftId: BigInt
    metaNftId_gt: BigInt
    metaNftId_gte: BigInt
    metaNftId_in: [BigInt!]
    metaNftId_lt: BigInt
    metaNftId_lte: BigInt
    metaNftId_not: BigInt
    metaNftId_not_in: [BigInt!]
    nftTokenID: BigInt
    nftTokenID_gt: BigInt
    nftTokenID_gte: BigInt
    nftTokenID_in: [BigInt!]
    nftTokenID_lt: BigInt
    nftTokenID_lte: BigInt
    nftTokenID_not: BigInt
    nftTokenID_not_in: [BigInt!]
    restrictionId: BigInt
    restrictionId_gt: BigInt
    restrictionId_gte: BigInt
    restrictionId_in: [BigInt!]
    restrictionId_lt: BigInt
    restrictionId_lte: BigInt
    restrictionId_not: BigInt
    restrictionId_not_in: [BigInt!]
    token: Bytes
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    unlockTimestamp: BigInt
    unlockTimestamp_gt: BigInt
    unlockTimestamp_gte: BigInt
    unlockTimestamp_in: [BigInt!]
    unlockTimestamp_lt: BigInt
    unlockTimestamp_lte: BigInt
    unlockTimestamp_not: BigInt
    unlockTimestamp_not_in: [BigInt!]
}

input WrappedEvent_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    blockTimestamp: BigInt
    blockTimestamp_gt: BigInt
    blockTimestamp_gte: BigInt
    blockTimestamp_in: [BigInt!]
    blockTimestamp_lt: BigInt
    blockTimestamp_lte: BigInt
    blockTimestamp_not: BigInt
    blockTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metaNftId: BigInt
    metaNftId_gt: BigInt
    metaNftId_gte: BigInt
    metaNftId_in: [BigInt!]
    metaNftId_lt: BigInt
    metaNftId_lte: BigInt
    metaNftId_not: BigInt
    metaNftId_not_in: [BigInt!]
    nftTokenID: BigInt
    nftTokenID_gt: BigInt
    nftTokenID_gte: BigInt
    nftTokenID_in: [BigInt!]
    nftTokenID_lt: BigInt
    nftTokenID_lte: BigInt
    nftTokenID_not: BigInt
    nftTokenID_not_in: [BigInt!]
    restrictionId: BigInt
    restrictionId_gt: BigInt
    restrictionId_gte: BigInt
    restrictionId_in: [BigInt!]
    restrictionId_lt: BigInt
    restrictionId_lte: BigInt
    restrictionId_not: BigInt
    restrictionId_not_in: [BigInt!]
    token: Bytes
    tokenType: BigInt
    tokenType_gt: BigInt
    tokenType_gte: BigInt
    tokenType_in: [BigInt!]
    tokenType_lt: BigInt
    tokenType_lte: BigInt
    tokenType_not: BigInt
    tokenType_not_in: [BigInt!]
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    unlockTimestamp: BigInt
    unlockTimestamp_gt: BigInt
    unlockTimestamp_gte: BigInt
    unlockTimestamp_in: [BigInt!]
    unlockTimestamp_lt: BigInt
    unlockTimestamp_lte: BigInt
    unlockTimestamp_not: BigInt
    unlockTimestamp_not_in: [BigInt!]
}
