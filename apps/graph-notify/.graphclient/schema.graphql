schema {
  query: Query
  subscription: Subscription
}

type Query {
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  swapContract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapContract
  swapContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapContract_orderBy
    orderDirection: OrderDirection
    where: SwapContract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapContract!]!
  swapLightContract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLightContract
  swapLightContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLightContract_orderBy
    orderDirection: OrderDirection
    where: SwapLightContract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLightContract!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  swapLight(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLight
  swapLights(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLight_orderBy
    orderDirection: OrderDirection
    where: SwapLight_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLight!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  indexer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Indexer
  indexers(
    skip: Int = 0
    first: Int = 100
    orderBy: Indexer_orderBy
    orderDirection: OrderDirection
    where: Indexer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Indexer!]!
  index(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  stake(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stake
  stakes(
    skip: Int = 0
    first: Int = 100
    orderBy: Stake_orderBy
    orderDirection: OrderDirection
    where: Stake_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stake!]!
  locator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Locator
  locators(
    skip: Int = 0
    first: Int = 100
    orderBy: Locator_orderBy
    orderDirection: OrderDirection
    where: Locator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Locator!]!
  delegateFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegateFactory
  delegateFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: DelegateFactory_orderBy
    orderDirection: OrderDirection
    where: DelegateFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DelegateFactory!]!
  delegate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegate
  delegates(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegate_orderBy
    orderDirection: OrderDirection
    where: Delegate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegate!]!
  rule(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rule
  rules(
    skip: Int = 0
    first: Int = 100
    orderBy: Rule_orderBy
    orderDirection: OrderDirection
    where: Rule_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Rule!]!
  locker(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Locker
  lockers(
    skip: Int = 0
    first: Int = 100
    orderBy: Locker_orderBy
    orderDirection: OrderDirection
    where: Locker_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Locker!]!
  pool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  poolClaim(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolClaim
  poolClaims(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolClaim_orderBy
    orderDirection: OrderDirection
    where: PoolClaim_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolClaim!]!
  enabledRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EnabledRoot
  enabledRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: EnabledRoot_orderBy
    orderDirection: OrderDirection
    where: EnabledRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EnabledRoot!]!
  collectedFeesDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollectedFeesDay
  collectedFeesDays(
    skip: Int = 0
    first: Int = 100
    orderBy: CollectedFeesDay_orderBy
    orderDirection: OrderDirection
    where: CollectedFeesDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollectedFeesDay!]!
  volumeDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VolumeDay
  volumeDays(
    skip: Int = 0
    first: Int = 100
    orderBy: VolumeDay_orderBy
    orderDirection: OrderDirection
    where: VolumeDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VolumeDay!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  swapContract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapContract
  swapContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapContract_orderBy
    orderDirection: OrderDirection
    where: SwapContract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapContract!]!
  swapLightContract(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLightContract
  swapLightContracts(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLightContract_orderBy
    orderDirection: OrderDirection
    where: SwapLightContract_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLightContract!]!
  swap(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    where: Swap_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Swap!]!
  swapLight(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapLight
  swapLights(
    skip: Int = 0
    first: Int = 100
    orderBy: SwapLight_orderBy
    orderDirection: OrderDirection
    where: SwapLight_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SwapLight!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  indexer(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Indexer
  indexers(
    skip: Int = 0
    first: Int = 100
    orderBy: Indexer_orderBy
    orderDirection: OrderDirection
    where: Indexer_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Indexer!]!
  index(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  stake(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stake
  stakes(
    skip: Int = 0
    first: Int = 100
    orderBy: Stake_orderBy
    orderDirection: OrderDirection
    where: Stake_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stake!]!
  locator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Locator
  locators(
    skip: Int = 0
    first: Int = 100
    orderBy: Locator_orderBy
    orderDirection: OrderDirection
    where: Locator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Locator!]!
  delegateFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DelegateFactory
  delegateFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: DelegateFactory_orderBy
    orderDirection: OrderDirection
    where: DelegateFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DelegateFactory!]!
  delegate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegate
  delegates(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegate_orderBy
    orderDirection: OrderDirection
    where: Delegate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegate!]!
  rule(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Rule
  rules(
    skip: Int = 0
    first: Int = 100
    orderBy: Rule_orderBy
    orderDirection: OrderDirection
    where: Rule_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Rule!]!
  locker(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Locker
  lockers(
    skip: Int = 0
    first: Int = 100
    orderBy: Locker_orderBy
    orderDirection: OrderDirection
    where: Locker_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Locker!]!
  pool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  poolClaim(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolClaim
  poolClaims(
    skip: Int = 0
    first: Int = 100
    orderBy: PoolClaim_orderBy
    orderDirection: OrderDirection
    where: PoolClaim_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PoolClaim!]!
  enabledRoot(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EnabledRoot
  enabledRoots(
    skip: Int = 0
    first: Int = 100
    orderBy: EnabledRoot_orderBy
    orderDirection: OrderDirection
    where: EnabledRoot_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EnabledRoot!]!
  collectedFeesDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollectedFeesDay
  collectedFeesDays(
    skip: Int = 0
    first: Int = 100
    orderBy: CollectedFeesDay_orderBy
    orderDirection: OrderDirection
    where: CollectedFeesDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollectedFeesDay!]!
  volumeDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VolumeDay
  volumeDays(
    skip: Int = 0
    first: Int = 100
    orderBy: VolumeDay_orderBy
    orderDirection: OrderDirection
    where: VolumeDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VolumeDay!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type CollectedFeesDay {
  id: ID!
  date: Int!
  amount: BigDecimal!
}

input CollectedFeesDay_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum CollectedFeesDay_orderBy {
  id
  date
  amount
}

type Delegate {
  id: ID!
  factory: DelegateFactory!
  swap: SwapContract!
  indexer: Indexer!
  owner: User!
  tradeWallet: Bytes!
}

type DelegateFactory {
  id: ID!
}

input DelegateFactory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum DelegateFactory_orderBy {
  id
}

input Delegate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  factory_: DelegateFactory_filter
  swap: String
  swap_not: String
  swap_gt: String
  swap_lt: String
  swap_gte: String
  swap_lte: String
  swap_in: [String!]
  swap_not_in: [String!]
  swap_contains: String
  swap_contains_nocase: String
  swap_not_contains: String
  swap_not_contains_nocase: String
  swap_starts_with: String
  swap_starts_with_nocase: String
  swap_not_starts_with: String
  swap_not_starts_with_nocase: String
  swap_ends_with: String
  swap_ends_with_nocase: String
  swap_not_ends_with: String
  swap_not_ends_with_nocase: String
  swap_: SwapContract_filter
  indexer: String
  indexer_not: String
  indexer_gt: String
  indexer_lt: String
  indexer_gte: String
  indexer_lte: String
  indexer_in: [String!]
  indexer_not_in: [String!]
  indexer_contains: String
  indexer_contains_nocase: String
  indexer_not_contains: String
  indexer_not_contains_nocase: String
  indexer_starts_with: String
  indexer_starts_with_nocase: String
  indexer_not_starts_with: String
  indexer_not_starts_with_nocase: String
  indexer_ends_with: String
  indexer_ends_with_nocase: String
  indexer_not_ends_with: String
  indexer_not_ends_with_nocase: String
  indexer_: Indexer_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: User_filter
  tradeWallet: Bytes
  tradeWallet_not: Bytes
  tradeWallet_in: [Bytes!]
  tradeWallet_not_in: [Bytes!]
  tradeWallet_contains: Bytes
  tradeWallet_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Delegate_orderBy {
  id
  factory
  swap
  indexer
  owner
  tradeWallet
}

type EnabledRoot {
  id: ID!
  pool: Pool!
  root: Bytes!
}

input EnabledRoot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: Pool_filter
  root: Bytes
  root_not: Bytes
  root_in: [Bytes!]
  root_not_in: [Bytes!]
  root_contains: Bytes
  root_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum EnabledRoot_orderBy {
  id
  pool
  root
}

type Index {
  id: ID!
  indexer: Indexer!
  signerToken: Token!
  senderToken: Token!
  protocol: Bytes!
}

input Index_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  indexer: String
  indexer_not: String
  indexer_gt: String
  indexer_lt: String
  indexer_gte: String
  indexer_lte: String
  indexer_in: [String!]
  indexer_not_in: [String!]
  indexer_contains: String
  indexer_contains_nocase: String
  indexer_not_contains: String
  indexer_not_contains_nocase: String
  indexer_starts_with: String
  indexer_starts_with_nocase: String
  indexer_not_starts_with: String
  indexer_not_starts_with_nocase: String
  indexer_ends_with: String
  indexer_ends_with_nocase: String
  indexer_not_ends_with: String
  indexer_not_ends_with_nocase: String
  indexer_: Indexer_filter
  signerToken: String
  signerToken_not: String
  signerToken_gt: String
  signerToken_lt: String
  signerToken_gte: String
  signerToken_lte: String
  signerToken_in: [String!]
  signerToken_not_in: [String!]
  signerToken_contains: String
  signerToken_contains_nocase: String
  signerToken_not_contains: String
  signerToken_not_contains_nocase: String
  signerToken_starts_with: String
  signerToken_starts_with_nocase: String
  signerToken_not_starts_with: String
  signerToken_not_starts_with_nocase: String
  signerToken_ends_with: String
  signerToken_ends_with_nocase: String
  signerToken_not_ends_with: String
  signerToken_not_ends_with_nocase: String
  signerToken_: Token_filter
  senderToken: String
  senderToken_not: String
  senderToken_gt: String
  senderToken_lt: String
  senderToken_gte: String
  senderToken_lte: String
  senderToken_in: [String!]
  senderToken_not_in: [String!]
  senderToken_contains: String
  senderToken_contains_nocase: String
  senderToken_not_contains: String
  senderToken_not_contains_nocase: String
  senderToken_starts_with: String
  senderToken_starts_with_nocase: String
  senderToken_not_starts_with: String
  senderToken_not_starts_with_nocase: String
  senderToken_ends_with: String
  senderToken_ends_with_nocase: String
  senderToken_not_ends_with: String
  senderToken_not_ends_with_nocase: String
  senderToken_: Token_filter
  protocol: Bytes
  protocol_not: Bytes
  protocol_in: [Bytes!]
  protocol_not_in: [Bytes!]
  protocol_contains: Bytes
  protocol_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Index_orderBy {
  id
  indexer
  signerToken
  senderToken
  protocol
}

type Indexer {
  id: ID!
}

input Indexer_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Indexer_orderBy {
  id
}

type Locator {
  id: ID!
  owner: User!
  index: Index!
  score: BigInt!
  locator: Bytes!
}

input Locator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: User_filter
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter
  score: BigInt
  score_not: BigInt
  score_gt: BigInt
  score_lt: BigInt
  score_gte: BigInt
  score_lte: BigInt
  score_in: [BigInt!]
  score_not_in: [BigInt!]
  locator: Bytes
  locator_not: Bytes
  locator_in: [Bytes!]
  locator_not_in: [Bytes!]
  locator_contains: Bytes
  locator_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Locator_orderBy {
  id
  owner
  index
  score
  locator
}

type Locker {
  id: ID!
  throttlingPercentage: BigInt
  throttlingDuration: BigInt
  throttlingBalance: BigInt
}

input Locker_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  throttlingPercentage: BigInt
  throttlingPercentage_not: BigInt
  throttlingPercentage_gt: BigInt
  throttlingPercentage_lt: BigInt
  throttlingPercentage_gte: BigInt
  throttlingPercentage_lte: BigInt
  throttlingPercentage_in: [BigInt!]
  throttlingPercentage_not_in: [BigInt!]
  throttlingDuration: BigInt
  throttlingDuration_not: BigInt
  throttlingDuration_gt: BigInt
  throttlingDuration_lt: BigInt
  throttlingDuration_gte: BigInt
  throttlingDuration_lte: BigInt
  throttlingDuration_in: [BigInt!]
  throttlingDuration_not_in: [BigInt!]
  throttlingBalance: BigInt
  throttlingBalance_not: BigInt
  throttlingBalance_gt: BigInt
  throttlingBalance_lt: BigInt
  throttlingBalance_gte: BigInt
  throttlingBalance_lte: BigInt
  throttlingBalance_in: [BigInt!]
  throttlingBalance_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Locker_orderBy {
  id
  throttlingPercentage
  throttlingDuration
  throttlingBalance
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  id: ID!
  scale: BigInt
  max: BigInt
  roots: [Bytes!]!
}

type PoolClaim {
  id: ID!
  pool: Pool!
  transactionHash: Bytes!
  user: User!
  token: Token!
  amount: BigInt!
}

input PoolClaim_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pool: String
  pool_not: String
  pool_gt: String
  pool_lt: String
  pool_gte: String
  pool_lte: String
  pool_in: [String!]
  pool_not_in: [String!]
  pool_contains: String
  pool_contains_nocase: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_: Pool_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PoolClaim_orderBy {
  id
  pool
  transactionHash
  user
  token
  amount
}

input Pool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  scale: BigInt
  scale_not: BigInt
  scale_gt: BigInt
  scale_lt: BigInt
  scale_gte: BigInt
  scale_lte: BigInt
  scale_in: [BigInt!]
  scale_not_in: [BigInt!]
  max: BigInt
  max_not: BigInt
  max_gt: BigInt
  max_lt: BigInt
  max_gte: BigInt
  max_lte: BigInt
  max_in: [BigInt!]
  max_not_in: [BigInt!]
  roots: [Bytes!]
  roots_not: [Bytes!]
  roots_contains: [Bytes!]
  roots_contains_nocase: [Bytes!]
  roots_not_contains: [Bytes!]
  roots_not_contains_nocase: [Bytes!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Pool_orderBy {
  id
  scale
  max
  roots
}

type Rule {
  id: ID!
  delegate: Delegate!
  owner: User!
  signerToken: Token!
  senderToken: Token!
  maxSenderAmount: BigInt!
  priceCoef: BigInt!
  priceExp: BigInt!
}

input Rule_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Delegate_filter
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: User_filter
  signerToken: String
  signerToken_not: String
  signerToken_gt: String
  signerToken_lt: String
  signerToken_gte: String
  signerToken_lte: String
  signerToken_in: [String!]
  signerToken_not_in: [String!]
  signerToken_contains: String
  signerToken_contains_nocase: String
  signerToken_not_contains: String
  signerToken_not_contains_nocase: String
  signerToken_starts_with: String
  signerToken_starts_with_nocase: String
  signerToken_not_starts_with: String
  signerToken_not_starts_with_nocase: String
  signerToken_ends_with: String
  signerToken_ends_with_nocase: String
  signerToken_not_ends_with: String
  signerToken_not_ends_with_nocase: String
  signerToken_: Token_filter
  senderToken: String
  senderToken_not: String
  senderToken_gt: String
  senderToken_lt: String
  senderToken_gte: String
  senderToken_lte: String
  senderToken_in: [String!]
  senderToken_not_in: [String!]
  senderToken_contains: String
  senderToken_contains_nocase: String
  senderToken_not_contains: String
  senderToken_not_contains_nocase: String
  senderToken_starts_with: String
  senderToken_starts_with_nocase: String
  senderToken_not_starts_with: String
  senderToken_not_starts_with_nocase: String
  senderToken_ends_with: String
  senderToken_ends_with_nocase: String
  senderToken_not_ends_with: String
  senderToken_not_ends_with_nocase: String
  senderToken_: Token_filter
  maxSenderAmount: BigInt
  maxSenderAmount_not: BigInt
  maxSenderAmount_gt: BigInt
  maxSenderAmount_lt: BigInt
  maxSenderAmount_gte: BigInt
  maxSenderAmount_lte: BigInt
  maxSenderAmount_in: [BigInt!]
  maxSenderAmount_not_in: [BigInt!]
  priceCoef: BigInt
  priceCoef_not: BigInt
  priceCoef_gt: BigInt
  priceCoef_lt: BigInt
  priceCoef_gte: BigInt
  priceCoef_lte: BigInt
  priceCoef_in: [BigInt!]
  priceCoef_not_in: [BigInt!]
  priceExp: BigInt
  priceExp_not: BigInt
  priceExp_gt: BigInt
  priceExp_lt: BigInt
  priceExp_gte: BigInt
  priceExp_lte: BigInt
  priceExp_in: [BigInt!]
  priceExp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Rule_orderBy {
  id
  delegate
  owner
  signerToken
  senderToken
  maxSenderAmount
  priceCoef
  priceExp
}

type Stake {
  id: ID!
  indexer: Indexer!
  staker: User!
  signerToken: Token!
  senderToken: Token!
  protocol: Bytes!
  stakeAmount: BigInt!
}

input Stake_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  indexer: String
  indexer_not: String
  indexer_gt: String
  indexer_lt: String
  indexer_gte: String
  indexer_lte: String
  indexer_in: [String!]
  indexer_not_in: [String!]
  indexer_contains: String
  indexer_contains_nocase: String
  indexer_not_contains: String
  indexer_not_contains_nocase: String
  indexer_starts_with: String
  indexer_starts_with_nocase: String
  indexer_not_starts_with: String
  indexer_not_starts_with_nocase: String
  indexer_ends_with: String
  indexer_ends_with_nocase: String
  indexer_not_ends_with: String
  indexer_not_ends_with_nocase: String
  indexer_: Indexer_filter
  staker: String
  staker_not: String
  staker_gt: String
  staker_lt: String
  staker_gte: String
  staker_lte: String
  staker_in: [String!]
  staker_not_in: [String!]
  staker_contains: String
  staker_contains_nocase: String
  staker_not_contains: String
  staker_not_contains_nocase: String
  staker_starts_with: String
  staker_starts_with_nocase: String
  staker_not_starts_with: String
  staker_not_starts_with_nocase: String
  staker_ends_with: String
  staker_ends_with_nocase: String
  staker_not_ends_with: String
  staker_not_ends_with_nocase: String
  staker_: User_filter
  signerToken: String
  signerToken_not: String
  signerToken_gt: String
  signerToken_lt: String
  signerToken_gte: String
  signerToken_lte: String
  signerToken_in: [String!]
  signerToken_not_in: [String!]
  signerToken_contains: String
  signerToken_contains_nocase: String
  signerToken_not_contains: String
  signerToken_not_contains_nocase: String
  signerToken_starts_with: String
  signerToken_starts_with_nocase: String
  signerToken_not_starts_with: String
  signerToken_not_starts_with_nocase: String
  signerToken_ends_with: String
  signerToken_ends_with_nocase: String
  signerToken_not_ends_with: String
  signerToken_not_ends_with_nocase: String
  signerToken_: Token_filter
  senderToken: String
  senderToken_not: String
  senderToken_gt: String
  senderToken_lt: String
  senderToken_gte: String
  senderToken_lte: String
  senderToken_in: [String!]
  senderToken_not_in: [String!]
  senderToken_contains: String
  senderToken_contains_nocase: String
  senderToken_not_contains: String
  senderToken_not_contains_nocase: String
  senderToken_starts_with: String
  senderToken_starts_with_nocase: String
  senderToken_not_starts_with: String
  senderToken_not_starts_with_nocase: String
  senderToken_ends_with: String
  senderToken_ends_with_nocase: String
  senderToken_not_ends_with: String
  senderToken_not_ends_with_nocase: String
  senderToken_: Token_filter
  protocol: Bytes
  protocol_not: Bytes
  protocol_in: [Bytes!]
  protocol_not_in: [Bytes!]
  protocol_contains: Bytes
  protocol_not_contains: Bytes
  stakeAmount: BigInt
  stakeAmount_not: BigInt
  stakeAmount_gt: BigInt
  stakeAmount_lt: BigInt
  stakeAmount_gte: BigInt
  stakeAmount_lte: BigInt
  stakeAmount_in: [BigInt!]
  stakeAmount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Stake_orderBy {
  id
  indexer
  staker
  signerToken
  senderToken
  protocol
  stakeAmount
}

type Swap {
  id: ID!
  swap: SwapContract!
  block: BigInt
  transactionHash: Bytes
  timestamp: BigInt
  from: Bytes
  to: Bytes
  value: BigInt
  nonce: BigInt
  expiry: BigInt
  signer: User
  signerAmount: BigInt
  signerId: BigInt
  signerToken: Token
  sender: User
  senderAmount: BigInt
  senderId: BigInt
  senderToken: Token
  affiliate: User
  affiliateAmount: BigInt
  affiliateId: BigInt
  affiliateToken: Token
}

type SwapContract {
  id: ID!
}

input SwapContract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SwapContract_orderBy {
  id
}

type SwapLight {
  id: ID!
  swap: SwapLightContract!
  block: BigInt
  transactionHash: Bytes
  timestamp: BigInt
  from: Bytes
  to: Bytes
  value: BigInt
  nonce: BigInt
  expiry: BigInt
  signer: User
  signerAmount: BigInt
  signerToken: Token
  signerFee: BigInt
  sender: User
  senderAmount: BigInt
  senderToken: Token
  swapValueUsd: BigInt
  feeValueUsd: BigInt
}

type SwapLightContract {
  id: ID!
}

input SwapLightContract_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SwapLightContract_orderBy {
  id
}

input SwapLight_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  swap: String
  swap_not: String
  swap_gt: String
  swap_lt: String
  swap_gte: String
  swap_lte: String
  swap_in: [String!]
  swap_not_in: [String!]
  swap_contains: String
  swap_contains_nocase: String
  swap_not_contains: String
  swap_not_contains_nocase: String
  swap_starts_with: String
  swap_starts_with_nocase: String
  swap_not_starts_with: String
  swap_not_starts_with_nocase: String
  swap_ends_with: String
  swap_ends_with_nocase: String
  swap_not_ends_with: String
  swap_not_ends_with_nocase: String
  swap_: SwapLightContract_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  from: Bytes
  from_not: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  signer: String
  signer_not: String
  signer_gt: String
  signer_lt: String
  signer_gte: String
  signer_lte: String
  signer_in: [String!]
  signer_not_in: [String!]
  signer_contains: String
  signer_contains_nocase: String
  signer_not_contains: String
  signer_not_contains_nocase: String
  signer_starts_with: String
  signer_starts_with_nocase: String
  signer_not_starts_with: String
  signer_not_starts_with_nocase: String
  signer_ends_with: String
  signer_ends_with_nocase: String
  signer_not_ends_with: String
  signer_not_ends_with_nocase: String
  signer_: User_filter
  signerAmount: BigInt
  signerAmount_not: BigInt
  signerAmount_gt: BigInt
  signerAmount_lt: BigInt
  signerAmount_gte: BigInt
  signerAmount_lte: BigInt
  signerAmount_in: [BigInt!]
  signerAmount_not_in: [BigInt!]
  signerToken: String
  signerToken_not: String
  signerToken_gt: String
  signerToken_lt: String
  signerToken_gte: String
  signerToken_lte: String
  signerToken_in: [String!]
  signerToken_not_in: [String!]
  signerToken_contains: String
  signerToken_contains_nocase: String
  signerToken_not_contains: String
  signerToken_not_contains_nocase: String
  signerToken_starts_with: String
  signerToken_starts_with_nocase: String
  signerToken_not_starts_with: String
  signerToken_not_starts_with_nocase: String
  signerToken_ends_with: String
  signerToken_ends_with_nocase: String
  signerToken_not_ends_with: String
  signerToken_not_ends_with_nocase: String
  signerToken_: Token_filter
  signerFee: BigInt
  signerFee_not: BigInt
  signerFee_gt: BigInt
  signerFee_lt: BigInt
  signerFee_gte: BigInt
  signerFee_lte: BigInt
  signerFee_in: [BigInt!]
  signerFee_not_in: [BigInt!]
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: User_filter
  senderAmount: BigInt
  senderAmount_not: BigInt
  senderAmount_gt: BigInt
  senderAmount_lt: BigInt
  senderAmount_gte: BigInt
  senderAmount_lte: BigInt
  senderAmount_in: [BigInt!]
  senderAmount_not_in: [BigInt!]
  senderToken: String
  senderToken_not: String
  senderToken_gt: String
  senderToken_lt: String
  senderToken_gte: String
  senderToken_lte: String
  senderToken_in: [String!]
  senderToken_not_in: [String!]
  senderToken_contains: String
  senderToken_contains_nocase: String
  senderToken_not_contains: String
  senderToken_not_contains_nocase: String
  senderToken_starts_with: String
  senderToken_starts_with_nocase: String
  senderToken_not_starts_with: String
  senderToken_not_starts_with_nocase: String
  senderToken_ends_with: String
  senderToken_ends_with_nocase: String
  senderToken_not_ends_with: String
  senderToken_not_ends_with_nocase: String
  senderToken_: Token_filter
  swapValueUsd: BigInt
  swapValueUsd_not: BigInt
  swapValueUsd_gt: BigInt
  swapValueUsd_lt: BigInt
  swapValueUsd_gte: BigInt
  swapValueUsd_lte: BigInt
  swapValueUsd_in: [BigInt!]
  swapValueUsd_not_in: [BigInt!]
  feeValueUsd: BigInt
  feeValueUsd_not: BigInt
  feeValueUsd_gt: BigInt
  feeValueUsd_lt: BigInt
  feeValueUsd_gte: BigInt
  feeValueUsd_lte: BigInt
  feeValueUsd_in: [BigInt!]
  feeValueUsd_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SwapLight_orderBy {
  id
  swap
  block
  transactionHash
  timestamp
  from
  to
  value
  nonce
  expiry
  signer
  signerAmount
  signerToken
  signerFee
  sender
  senderAmount
  senderToken
  swapValueUsd
  feeValueUsd
}

input Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  swap: String
  swap_not: String
  swap_gt: String
  swap_lt: String
  swap_gte: String
  swap_lte: String
  swap_in: [String!]
  swap_not_in: [String!]
  swap_contains: String
  swap_contains_nocase: String
  swap_not_contains: String
  swap_not_contains_nocase: String
  swap_starts_with: String
  swap_starts_with_nocase: String
  swap_not_starts_with: String
  swap_not_starts_with_nocase: String
  swap_ends_with: String
  swap_ends_with_nocase: String
  swap_not_ends_with: String
  swap_not_ends_with_nocase: String
  swap_: SwapContract_filter
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  from: Bytes
  from_not: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  nonce: BigInt
  nonce_not: BigInt
  nonce_gt: BigInt
  nonce_lt: BigInt
  nonce_gte: BigInt
  nonce_lte: BigInt
  nonce_in: [BigInt!]
  nonce_not_in: [BigInt!]
  expiry: BigInt
  expiry_not: BigInt
  expiry_gt: BigInt
  expiry_lt: BigInt
  expiry_gte: BigInt
  expiry_lte: BigInt
  expiry_in: [BigInt!]
  expiry_not_in: [BigInt!]
  signer: String
  signer_not: String
  signer_gt: String
  signer_lt: String
  signer_gte: String
  signer_lte: String
  signer_in: [String!]
  signer_not_in: [String!]
  signer_contains: String
  signer_contains_nocase: String
  signer_not_contains: String
  signer_not_contains_nocase: String
  signer_starts_with: String
  signer_starts_with_nocase: String
  signer_not_starts_with: String
  signer_not_starts_with_nocase: String
  signer_ends_with: String
  signer_ends_with_nocase: String
  signer_not_ends_with: String
  signer_not_ends_with_nocase: String
  signer_: User_filter
  signerAmount: BigInt
  signerAmount_not: BigInt
  signerAmount_gt: BigInt
  signerAmount_lt: BigInt
  signerAmount_gte: BigInt
  signerAmount_lte: BigInt
  signerAmount_in: [BigInt!]
  signerAmount_not_in: [BigInt!]
  signerId: BigInt
  signerId_not: BigInt
  signerId_gt: BigInt
  signerId_lt: BigInt
  signerId_gte: BigInt
  signerId_lte: BigInt
  signerId_in: [BigInt!]
  signerId_not_in: [BigInt!]
  signerToken: String
  signerToken_not: String
  signerToken_gt: String
  signerToken_lt: String
  signerToken_gte: String
  signerToken_lte: String
  signerToken_in: [String!]
  signerToken_not_in: [String!]
  signerToken_contains: String
  signerToken_contains_nocase: String
  signerToken_not_contains: String
  signerToken_not_contains_nocase: String
  signerToken_starts_with: String
  signerToken_starts_with_nocase: String
  signerToken_not_starts_with: String
  signerToken_not_starts_with_nocase: String
  signerToken_ends_with: String
  signerToken_ends_with_nocase: String
  signerToken_not_ends_with: String
  signerToken_not_ends_with_nocase: String
  signerToken_: Token_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: User_filter
  senderAmount: BigInt
  senderAmount_not: BigInt
  senderAmount_gt: BigInt
  senderAmount_lt: BigInt
  senderAmount_gte: BigInt
  senderAmount_lte: BigInt
  senderAmount_in: [BigInt!]
  senderAmount_not_in: [BigInt!]
  senderId: BigInt
  senderId_not: BigInt
  senderId_gt: BigInt
  senderId_lt: BigInt
  senderId_gte: BigInt
  senderId_lte: BigInt
  senderId_in: [BigInt!]
  senderId_not_in: [BigInt!]
  senderToken: String
  senderToken_not: String
  senderToken_gt: String
  senderToken_lt: String
  senderToken_gte: String
  senderToken_lte: String
  senderToken_in: [String!]
  senderToken_not_in: [String!]
  senderToken_contains: String
  senderToken_contains_nocase: String
  senderToken_not_contains: String
  senderToken_not_contains_nocase: String
  senderToken_starts_with: String
  senderToken_starts_with_nocase: String
  senderToken_not_starts_with: String
  senderToken_not_starts_with_nocase: String
  senderToken_ends_with: String
  senderToken_ends_with_nocase: String
  senderToken_not_ends_with: String
  senderToken_not_ends_with_nocase: String
  senderToken_: Token_filter
  affiliate: String
  affiliate_not: String
  affiliate_gt: String
  affiliate_lt: String
  affiliate_gte: String
  affiliate_lte: String
  affiliate_in: [String!]
  affiliate_not_in: [String!]
  affiliate_contains: String
  affiliate_contains_nocase: String
  affiliate_not_contains: String
  affiliate_not_contains_nocase: String
  affiliate_starts_with: String
  affiliate_starts_with_nocase: String
  affiliate_not_starts_with: String
  affiliate_not_starts_with_nocase: String
  affiliate_ends_with: String
  affiliate_ends_with_nocase: String
  affiliate_not_ends_with: String
  affiliate_not_ends_with_nocase: String
  affiliate_: User_filter
  affiliateAmount: BigInt
  affiliateAmount_not: BigInt
  affiliateAmount_gt: BigInt
  affiliateAmount_lt: BigInt
  affiliateAmount_gte: BigInt
  affiliateAmount_lte: BigInt
  affiliateAmount_in: [BigInt!]
  affiliateAmount_not_in: [BigInt!]
  affiliateId: BigInt
  affiliateId_not: BigInt
  affiliateId_gt: BigInt
  affiliateId_lt: BigInt
  affiliateId_gte: BigInt
  affiliateId_lte: BigInt
  affiliateId_in: [BigInt!]
  affiliateId_not_in: [BigInt!]
  affiliateToken: String
  affiliateToken_not: String
  affiliateToken_gt: String
  affiliateToken_lt: String
  affiliateToken_gte: String
  affiliateToken_lte: String
  affiliateToken_in: [String!]
  affiliateToken_not_in: [String!]
  affiliateToken_contains: String
  affiliateToken_contains_nocase: String
  affiliateToken_not_contains: String
  affiliateToken_not_contains_nocase: String
  affiliateToken_starts_with: String
  affiliateToken_starts_with_nocase: String
  affiliateToken_not_starts_with: String
  affiliateToken_not_starts_with_nocase: String
  affiliateToken_ends_with: String
  affiliateToken_ends_with_nocase: String
  affiliateToken_not_ends_with: String
  affiliateToken_not_ends_with_nocase: String
  affiliateToken_: Token_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Swap_orderBy {
  id
  swap
  block
  transactionHash
  timestamp
  from
  to
  value
  nonce
  expiry
  signer
  signerAmount
  signerId
  signerToken
  sender
  senderAmount
  senderId
  senderToken
  affiliate
  affiliateAmount
  affiliateId
  affiliateToken
}

type Token {
  id: ID!
  isBlacklisted: Boolean
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  isBlacklisted: Boolean
  isBlacklisted_not: Boolean
  isBlacklisted_in: [Boolean!]
  isBlacklisted_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Token_orderBy {
  id
  isBlacklisted
}

type User {
  id: ID!
  authorizedSigners(skip: Int = 0, first: Int = 100, orderBy: User_orderBy, orderDirection: OrderDirection, where: User_filter): [User!]!
  authorizedSenders(skip: Int = 0, first: Int = 100, orderBy: User_orderBy, orderDirection: OrderDirection, where: User_filter): [User!]!
  cancelledSwapNonces: [BigInt!]!
  cancelledSwapLightNonces: [BigInt!]!
  amountInLocker: BigInt
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  authorizedSigners: [String!]
  authorizedSigners_not: [String!]
  authorizedSigners_contains: [String!]
  authorizedSigners_contains_nocase: [String!]
  authorizedSigners_not_contains: [String!]
  authorizedSigners_not_contains_nocase: [String!]
  authorizedSigners_: User_filter
  authorizedSenders: [String!]
  authorizedSenders_not: [String!]
  authorizedSenders_contains: [String!]
  authorizedSenders_contains_nocase: [String!]
  authorizedSenders_not_contains: [String!]
  authorizedSenders_not_contains_nocase: [String!]
  authorizedSenders_: User_filter
  cancelledSwapNonces: [BigInt!]
  cancelledSwapNonces_not: [BigInt!]
  cancelledSwapNonces_contains: [BigInt!]
  cancelledSwapNonces_contains_nocase: [BigInt!]
  cancelledSwapNonces_not_contains: [BigInt!]
  cancelledSwapNonces_not_contains_nocase: [BigInt!]
  cancelledSwapLightNonces: [BigInt!]
  cancelledSwapLightNonces_not: [BigInt!]
  cancelledSwapLightNonces_contains: [BigInt!]
  cancelledSwapLightNonces_contains_nocase: [BigInt!]
  cancelledSwapLightNonces_not_contains: [BigInt!]
  cancelledSwapLightNonces_not_contains_nocase: [BigInt!]
  amountInLocker: BigInt
  amountInLocker_not: BigInt
  amountInLocker_gt: BigInt
  amountInLocker_lt: BigInt
  amountInLocker_gte: BigInt
  amountInLocker_lte: BigInt
  amountInLocker_in: [BigInt!]
  amountInLocker_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum User_orderBy {
  id
  authorizedSigners
  authorizedSenders
  cancelledSwapNonces
  cancelledSwapLightNonces
  amountInLocker
}

type VolumeDay {
  id: ID!
  date: Int!
  amount: BigDecimal!
}

input VolumeDay_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum VolumeDay_orderBy {
  id
  date
  amount
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
  chainName: String!
  subgraphUrl: String!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}