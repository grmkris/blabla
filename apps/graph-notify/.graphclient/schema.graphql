schema {
  query: Query
  subscription: Subscription
}

type Query {
  protocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Protocol
  protocols(
    skip: Int = 0
    first: Int = 100
    orderBy: Protocol_orderBy
    orderDirection: OrderDirection
    where: Protocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Protocol!]!
  transcoder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transcoder
  transcoders(
    skip: Int = 0
    first: Int = 100
    orderBy: Transcoder_orderBy
    orderDirection: OrderDirection
    where: Transcoder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transcoder!]!
  pool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  round(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Round
  rounds(
    skip: Int = 0
    first: Int = 100
    orderBy: Round_orderBy
    orderDirection: OrderDirection
    where: Round_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Round!]!
  delegator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegator
  delegators(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegator_orderBy
    orderDirection: OrderDirection
    where: Delegator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegator!]!
  broadcaster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Broadcaster
  broadcasters(
    skip: Int = 0
    first: Int = 100
    orderBy: Broadcaster_orderBy
    orderDirection: OrderDirection
    where: Broadcaster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Broadcaster!]!
  unbondingLock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnbondingLock
  unbondingLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: UnbondingLock_orderBy
    orderDirection: OrderDirection
    where: UnbondingLock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnbondingLock!]!
  poll(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Poll
  polls(
    skip: Int = 0
    first: Int = 100
    orderBy: Poll_orderBy
    orderDirection: OrderDirection
    where: Poll_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Poll!]!
  pollTally(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PollTally
  pollTallies(
    skip: Int = 0
    first: Int = 100
    orderBy: PollTally_orderBy
    orderDirection: OrderDirection
    where: PollTally_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PollTally!]!
  vote(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: Vote_orderBy
    orderDirection: OrderDirection
    where: Vote_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  day(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Day
  days(
    skip: Int = 0
    first: Int = 100
    orderBy: Day_orderBy
    orderDirection: OrderDirection
    where: Day_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Day!]!
  transcoderDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderDay
  transcoderDays(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderDay_orderBy
    orderDirection: OrderDirection
    where: TranscoderDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderDay!]!
  transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  bondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondEvent
  bondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BondEvent_orderBy
    orderDirection: OrderDirection
    where: BondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondEvent!]!
  unbondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnbondEvent
  unbondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UnbondEvent_orderBy
    orderDirection: OrderDirection
    where: UnbondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnbondEvent!]!
  rebondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RebondEvent
  rebondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RebondEvent_orderBy
    orderDirection: OrderDirection
    where: RebondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RebondEvent!]!
  rewardEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardEvent
  rewardEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardEvent_orderBy
    orderDirection: OrderDirection
    where: RewardEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardEvent!]!
  transcoderActivatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderActivatedEvent
  transcoderActivatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderActivatedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderActivatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderActivatedEvent!]!
  transcoderDeactivatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderDeactivatedEvent
  transcoderDeactivatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderDeactivatedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderDeactivatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderDeactivatedEvent!]!
  earningsClaimedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EarningsClaimedEvent
  earningsClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: EarningsClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: EarningsClaimedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EarningsClaimedEvent!]!
  transcoderUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderUpdateEvent
  transcoderUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderUpdateEvent!]!
  transcoderSlashedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderSlashedEvent
  transcoderSlashedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderSlashedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderSlashedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderSlashedEvent!]!
  transcoderResignedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderResignedEvent
  transcoderResignedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderResignedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderResignedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderResignedEvent!]!
  transcoderEvictedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderEvictedEvent
  transcoderEvictedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderEvictedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderEvictedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderEvictedEvent!]!
  withdrawStakeEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawStakeEvent
  withdrawStakeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawStakeEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawStakeEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawStakeEvent!]!
  withdrawFeesEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawFeesEvent
  withdrawFeesEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawFeesEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawFeesEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawFeesEvent!]!
  newRoundEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewRoundEvent
  newRoundEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: NewRoundEvent_orderBy
    orderDirection: OrderDirection
    where: NewRoundEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewRoundEvent!]!
  winningTicketRedeemedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WinningTicketRedeemedEvent
  winningTicketRedeemedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WinningTicketRedeemedEvent_orderBy
    orderDirection: OrderDirection
    where: WinningTicketRedeemedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WinningTicketRedeemedEvent!]!
  depositFundedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositFundedEvent
  depositFundedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositFundedEvent_orderBy
    orderDirection: OrderDirection
    where: DepositFundedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositFundedEvent!]!
  reserveFundedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ReserveFundedEvent
  reserveFundedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ReserveFundedEvent_orderBy
    orderDirection: OrderDirection
    where: ReserveFundedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ReserveFundedEvent!]!
  reserveClaimedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ReserveClaimedEvent
  reserveClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ReserveClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: ReserveClaimedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ReserveClaimedEvent!]!
  withdrawalEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawalEvent
  withdrawalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawalEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawalEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawalEvent!]!
  setCurrentRewardTokensEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetCurrentRewardTokensEvent
  setCurrentRewardTokensEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetCurrentRewardTokensEvent_orderBy
    orderDirection: OrderDirection
    where: SetCurrentRewardTokensEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetCurrentRewardTokensEvent!]!
  pauseEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PauseEvent
  pauseEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PauseEvent_orderBy
    orderDirection: OrderDirection
    where: PauseEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PauseEvent!]!
  unpauseEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnpauseEvent
  unpauseEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UnpauseEvent_orderBy
    orderDirection: OrderDirection
    where: UnpauseEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnpauseEvent!]!
  parameterUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ParameterUpdateEvent
  parameterUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ParameterUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: ParameterUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ParameterUpdateEvent!]!
  voteEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteEvent
  voteEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteEvent_orderBy
    orderDirection: OrderDirection
    where: VoteEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteEvent!]!
  pollCreatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PollCreatedEvent
  pollCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PollCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: PollCreatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PollCreatedEvent!]!
  serviceURIUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ServiceURIUpdateEvent
  serviceURIUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ServiceURIUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: ServiceURIUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ServiceURIUpdateEvent!]!
  mintEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintEvent
  mintEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintEvent_orderBy
    orderDirection: OrderDirection
    where: MintEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintEvent!]!
  burnEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnEvent
  burnEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnEvent_orderBy
    orderDirection: OrderDirection
    where: BurnEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnEvent!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  protocol(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Protocol
  protocols(
    skip: Int = 0
    first: Int = 100
    orderBy: Protocol_orderBy
    orderDirection: OrderDirection
    where: Protocol_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Protocol!]!
  transcoder(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transcoder
  transcoders(
    skip: Int = 0
    first: Int = 100
    orderBy: Transcoder_orderBy
    orderDirection: OrderDirection
    where: Transcoder_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transcoder!]!
  pool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  pools(
    skip: Int = 0
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    where: Pool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Pool!]!
  round(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Round
  rounds(
    skip: Int = 0
    first: Int = 100
    orderBy: Round_orderBy
    orderDirection: OrderDirection
    where: Round_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Round!]!
  delegator(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Delegator
  delegators(
    skip: Int = 0
    first: Int = 100
    orderBy: Delegator_orderBy
    orderDirection: OrderDirection
    where: Delegator_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Delegator!]!
  broadcaster(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Broadcaster
  broadcasters(
    skip: Int = 0
    first: Int = 100
    orderBy: Broadcaster_orderBy
    orderDirection: OrderDirection
    where: Broadcaster_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Broadcaster!]!
  unbondingLock(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnbondingLock
  unbondingLocks(
    skip: Int = 0
    first: Int = 100
    orderBy: UnbondingLock_orderBy
    orderDirection: OrderDirection
    where: UnbondingLock_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnbondingLock!]!
  poll(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Poll
  polls(
    skip: Int = 0
    first: Int = 100
    orderBy: Poll_orderBy
    orderDirection: OrderDirection
    where: Poll_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Poll!]!
  pollTally(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PollTally
  pollTallies(
    skip: Int = 0
    first: Int = 100
    orderBy: PollTally_orderBy
    orderDirection: OrderDirection
    where: PollTally_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PollTally!]!
  vote(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vote
  votes(
    skip: Int = 0
    first: Int = 100
    orderBy: Vote_orderBy
    orderDirection: OrderDirection
    where: Vote_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vote!]!
  day(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Day
  days(
    skip: Int = 0
    first: Int = 100
    orderBy: Day_orderBy
    orderDirection: OrderDirection
    where: Day_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Day!]!
  transcoderDay(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderDay
  transcoderDays(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderDay_orderBy
    orderDirection: OrderDirection
    where: TranscoderDay_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderDay!]!
  transaction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Transaction
  transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: Transaction_orderBy
    orderDirection: OrderDirection
    where: Transaction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Transaction!]!
  bondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondEvent
  bondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BondEvent_orderBy
    orderDirection: OrderDirection
    where: BondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondEvent!]!
  unbondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnbondEvent
  unbondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UnbondEvent_orderBy
    orderDirection: OrderDirection
    where: UnbondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnbondEvent!]!
  rebondEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RebondEvent
  rebondEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RebondEvent_orderBy
    orderDirection: OrderDirection
    where: RebondEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RebondEvent!]!
  rewardEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardEvent
  rewardEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardEvent_orderBy
    orderDirection: OrderDirection
    where: RewardEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardEvent!]!
  transcoderActivatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderActivatedEvent
  transcoderActivatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderActivatedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderActivatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderActivatedEvent!]!
  transcoderDeactivatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderDeactivatedEvent
  transcoderDeactivatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderDeactivatedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderDeactivatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderDeactivatedEvent!]!
  earningsClaimedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): EarningsClaimedEvent
  earningsClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: EarningsClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: EarningsClaimedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [EarningsClaimedEvent!]!
  transcoderUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderUpdateEvent
  transcoderUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderUpdateEvent!]!
  transcoderSlashedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderSlashedEvent
  transcoderSlashedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderSlashedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderSlashedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderSlashedEvent!]!
  transcoderResignedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderResignedEvent
  transcoderResignedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderResignedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderResignedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderResignedEvent!]!
  transcoderEvictedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TranscoderEvictedEvent
  transcoderEvictedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TranscoderEvictedEvent_orderBy
    orderDirection: OrderDirection
    where: TranscoderEvictedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TranscoderEvictedEvent!]!
  withdrawStakeEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawStakeEvent
  withdrawStakeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawStakeEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawStakeEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawStakeEvent!]!
  withdrawFeesEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawFeesEvent
  withdrawFeesEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawFeesEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawFeesEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawFeesEvent!]!
  newRoundEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewRoundEvent
  newRoundEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: NewRoundEvent_orderBy
    orderDirection: OrderDirection
    where: NewRoundEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewRoundEvent!]!
  winningTicketRedeemedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WinningTicketRedeemedEvent
  winningTicketRedeemedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WinningTicketRedeemedEvent_orderBy
    orderDirection: OrderDirection
    where: WinningTicketRedeemedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WinningTicketRedeemedEvent!]!
  depositFundedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DepositFundedEvent
  depositFundedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DepositFundedEvent_orderBy
    orderDirection: OrderDirection
    where: DepositFundedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DepositFundedEvent!]!
  reserveFundedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ReserveFundedEvent
  reserveFundedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ReserveFundedEvent_orderBy
    orderDirection: OrderDirection
    where: ReserveFundedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ReserveFundedEvent!]!
  reserveClaimedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ReserveClaimedEvent
  reserveClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ReserveClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: ReserveClaimedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ReserveClaimedEvent!]!
  withdrawalEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WithdrawalEvent
  withdrawalEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: WithdrawalEvent_orderBy
    orderDirection: OrderDirection
    where: WithdrawalEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WithdrawalEvent!]!
  setCurrentRewardTokensEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetCurrentRewardTokensEvent
  setCurrentRewardTokensEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetCurrentRewardTokensEvent_orderBy
    orderDirection: OrderDirection
    where: SetCurrentRewardTokensEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetCurrentRewardTokensEvent!]!
  pauseEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PauseEvent
  pauseEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PauseEvent_orderBy
    orderDirection: OrderDirection
    where: PauseEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PauseEvent!]!
  unpauseEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UnpauseEvent
  unpauseEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: UnpauseEvent_orderBy
    orderDirection: OrderDirection
    where: UnpauseEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UnpauseEvent!]!
  parameterUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ParameterUpdateEvent
  parameterUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ParameterUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: ParameterUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ParameterUpdateEvent!]!
  voteEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VoteEvent
  voteEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: VoteEvent_orderBy
    orderDirection: OrderDirection
    where: VoteEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VoteEvent!]!
  pollCreatedEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PollCreatedEvent
  pollCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PollCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: PollCreatedEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PollCreatedEvent!]!
  serviceURIUpdateEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ServiceURIUpdateEvent
  serviceURIUpdateEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ServiceURIUpdateEvent_orderBy
    orderDirection: OrderDirection
    where: ServiceURIUpdateEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ServiceURIUpdateEvent!]!
  mintEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintEvent
  mintEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintEvent_orderBy
    orderDirection: OrderDirection
    where: MintEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintEvent!]!
  burnEvent(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnEvent
  burnEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnEvent_orderBy
    orderDirection: OrderDirection
    where: BurnEvent_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnEvent!]!
  event(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

"""
BondEvent entities are created for every emitted Bond event.

"""
type BondEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in, used to sort"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Delegator's current total bonded amount"""
  bondedAmount: BigDecimal!
  """Additional amount added to bonded amount"""
  additionalAmount: BigDecimal!
  """Reference to the Delegator's new delegate"""
  newDelegate: Transcoder!
  """Reference to the Delegator's old delegate"""
  oldDelegate: Transcoder!
  """Reference to the Delegator that bonded"""
  delegator: Delegator!
}

input BondEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  bondedAmount: BigDecimal
  bondedAmount_not: BigDecimal
  bondedAmount_gt: BigDecimal
  bondedAmount_lt: BigDecimal
  bondedAmount_gte: BigDecimal
  bondedAmount_lte: BigDecimal
  bondedAmount_in: [BigDecimal!]
  bondedAmount_not_in: [BigDecimal!]
  additionalAmount: BigDecimal
  additionalAmount_not: BigDecimal
  additionalAmount_gt: BigDecimal
  additionalAmount_lt: BigDecimal
  additionalAmount_gte: BigDecimal
  additionalAmount_lte: BigDecimal
  additionalAmount_in: [BigDecimal!]
  additionalAmount_not_in: [BigDecimal!]
  newDelegate: String
  newDelegate_not: String
  newDelegate_gt: String
  newDelegate_lt: String
  newDelegate_gte: String
  newDelegate_lte: String
  newDelegate_in: [String!]
  newDelegate_not_in: [String!]
  newDelegate_contains: String
  newDelegate_contains_nocase: String
  newDelegate_not_contains: String
  newDelegate_not_contains_nocase: String
  newDelegate_starts_with: String
  newDelegate_starts_with_nocase: String
  newDelegate_not_starts_with: String
  newDelegate_not_starts_with_nocase: String
  newDelegate_ends_with: String
  newDelegate_ends_with_nocase: String
  newDelegate_not_ends_with: String
  newDelegate_not_ends_with_nocase: String
  newDelegate_: Transcoder_filter
  oldDelegate: String
  oldDelegate_not: String
  oldDelegate_gt: String
  oldDelegate_lt: String
  oldDelegate_gte: String
  oldDelegate_lte: String
  oldDelegate_in: [String!]
  oldDelegate_not_in: [String!]
  oldDelegate_contains: String
  oldDelegate_contains_nocase: String
  oldDelegate_not_contains: String
  oldDelegate_not_contains_nocase: String
  oldDelegate_starts_with: String
  oldDelegate_starts_with_nocase: String
  oldDelegate_not_starts_with: String
  oldDelegate_not_starts_with_nocase: String
  oldDelegate_ends_with: String
  oldDelegate_ends_with_nocase: String
  oldDelegate_not_ends_with: String
  oldDelegate_not_ends_with_nocase: String
  oldDelegate_: Transcoder_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum BondEvent_orderBy {
  id
  transaction
  timestamp
  round
  bondedAmount
  additionalAmount
  newDelegate
  oldDelegate
  delegator
}

"""
Broadcasters pay transcoders to do the work of transcoding in exchange for fees

"""
type Broadcaster {
  """ETH address of a broadcaster"""
  id: ID!
  """Amount of funds deposited"""
  deposit: BigDecimal!
  """Amount of funds in reserve"""
  reserve: BigDecimal!
}

input Broadcaster_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  deposit: BigDecimal
  deposit_not: BigDecimal
  deposit_gt: BigDecimal
  deposit_lt: BigDecimal
  deposit_gte: BigDecimal
  deposit_lte: BigDecimal
  deposit_in: [BigDecimal!]
  deposit_not_in: [BigDecimal!]
  reserve: BigDecimal
  reserve_not: BigDecimal
  reserve_gt: BigDecimal
  reserve_lt: BigDecimal
  reserve_gte: BigDecimal
  reserve_lte: BigDecimal
  reserve_in: [BigDecimal!]
  reserve_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Broadcaster_orderBy {
  id
  deposit
  reserve
}

"""
BurnEvent entities are created for every emitted Burn event.

"""
type BurnEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Amount of tokens burned"""
  value: BigDecimal!
}

input BurnEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  value: BigDecimal
  value_not: BigDecimal
  value_gt: BigDecimal
  value_lt: BigDecimal
  value_gte: BigDecimal
  value_lte: BigDecimal
  value_in: [BigDecimal!]
  value_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum BurnEvent_orderBy {
  id
  transaction
  timestamp
  round
  value
}

scalar Bytes

"""
Protocol data accumulated and condensed into day stats

"""
type Day {
  """Timestamp rounded to current day by dividing by 86400"""
  id: ID!
  """The date beginning at 12:00am UTC"""
  date: Int!
  """Fees generated this day in ETH"""
  volumeETH: BigDecimal!
  """Fees generated this day in USD"""
  volumeUSD: BigDecimal!
  """Total active stake during the day"""
  totalActiveStake: BigDecimal!
  """Total Livepeer token supply during the day"""
  totalSupply: BigDecimal!
  """Participation rate during the day (totalActiveStake/totalSupply)"""
  participationRate: BigDecimal!
}

input Day_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  volumeETH: BigDecimal
  volumeETH_not: BigDecimal
  volumeETH_gt: BigDecimal
  volumeETH_lt: BigDecimal
  volumeETH_gte: BigDecimal
  volumeETH_lte: BigDecimal
  volumeETH_in: [BigDecimal!]
  volumeETH_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  totalActiveStake: BigDecimal
  totalActiveStake_not: BigDecimal
  totalActiveStake_gt: BigDecimal
  totalActiveStake_lt: BigDecimal
  totalActiveStake_gte: BigDecimal
  totalActiveStake_lte: BigDecimal
  totalActiveStake_in: [BigDecimal!]
  totalActiveStake_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  participationRate: BigDecimal
  participationRate_not: BigDecimal
  participationRate_gt: BigDecimal
  participationRate_lt: BigDecimal
  participationRate_gte: BigDecimal
  participationRate_lte: BigDecimal
  participationRate_in: [BigDecimal!]
  participationRate_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Day_orderBy {
  id
  date
  volumeETH
  volumeUSD
  totalActiveStake
  totalSupply
  participationRate
}

"""
Bonded accounts who have delegated their stake towards a transcoder candidate

"""
type Delegator {
  """ETH address of a delegator"""
  id: ID!
  """ETH address of the delegate (the one whom the delegator has bonded to)"""
  delegate: Transcoder
  """Round the delegator becomes bonded and delegated to its delegate"""
  startRound: BigInt!
  """Last round that the delegator claimed reward and fee pool shares"""
  lastClaimRound: Round
  """Amount of Livepeer Token a delegator currently has bonded"""
  bondedAmount: BigDecimal!
  """
  Amount of Livepeer Token a delegator has bonded over its lifetime separate from rewards
  """
  principal: BigDecimal!
  """Amount of Livepeer Token a delegator has unbonded over its lifetime"""
  unbonded: BigDecimal!
  """Amount of fees a delegator has collected"""
  fees: BigDecimal!
  """Amount of fees withdrawn"""
  withdrawnFees: BigDecimal!
  """Amount of Livepeer Token the delegator has delegated"""
  delegatedAmount: BigDecimal!
  """Unbonding locks associated with the delegator"""
  unbondingLocks(skip: Int = 0, first: Int = 100, orderBy: UnbondingLock_orderBy, orderDirection: OrderDirection, where: UnbondingLock_filter): [UnbondingLock!]
}

input Delegator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  startRound: BigInt
  startRound_not: BigInt
  startRound_gt: BigInt
  startRound_lt: BigInt
  startRound_gte: BigInt
  startRound_lte: BigInt
  startRound_in: [BigInt!]
  startRound_not_in: [BigInt!]
  lastClaimRound: String
  lastClaimRound_not: String
  lastClaimRound_gt: String
  lastClaimRound_lt: String
  lastClaimRound_gte: String
  lastClaimRound_lte: String
  lastClaimRound_in: [String!]
  lastClaimRound_not_in: [String!]
  lastClaimRound_contains: String
  lastClaimRound_contains_nocase: String
  lastClaimRound_not_contains: String
  lastClaimRound_not_contains_nocase: String
  lastClaimRound_starts_with: String
  lastClaimRound_starts_with_nocase: String
  lastClaimRound_not_starts_with: String
  lastClaimRound_not_starts_with_nocase: String
  lastClaimRound_ends_with: String
  lastClaimRound_ends_with_nocase: String
  lastClaimRound_not_ends_with: String
  lastClaimRound_not_ends_with_nocase: String
  lastClaimRound_: Round_filter
  bondedAmount: BigDecimal
  bondedAmount_not: BigDecimal
  bondedAmount_gt: BigDecimal
  bondedAmount_lt: BigDecimal
  bondedAmount_gte: BigDecimal
  bondedAmount_lte: BigDecimal
  bondedAmount_in: [BigDecimal!]
  bondedAmount_not_in: [BigDecimal!]
  principal: BigDecimal
  principal_not: BigDecimal
  principal_gt: BigDecimal
  principal_lt: BigDecimal
  principal_gte: BigDecimal
  principal_lte: BigDecimal
  principal_in: [BigDecimal!]
  principal_not_in: [BigDecimal!]
  unbonded: BigDecimal
  unbonded_not: BigDecimal
  unbonded_gt: BigDecimal
  unbonded_lt: BigDecimal
  unbonded_gte: BigDecimal
  unbonded_lte: BigDecimal
  unbonded_in: [BigDecimal!]
  unbonded_not_in: [BigDecimal!]
  fees: BigDecimal
  fees_not: BigDecimal
  fees_gt: BigDecimal
  fees_lt: BigDecimal
  fees_gte: BigDecimal
  fees_lte: BigDecimal
  fees_in: [BigDecimal!]
  fees_not_in: [BigDecimal!]
  withdrawnFees: BigDecimal
  withdrawnFees_not: BigDecimal
  withdrawnFees_gt: BigDecimal
  withdrawnFees_lt: BigDecimal
  withdrawnFees_gte: BigDecimal
  withdrawnFees_lte: BigDecimal
  withdrawnFees_in: [BigDecimal!]
  withdrawnFees_not_in: [BigDecimal!]
  delegatedAmount: BigDecimal
  delegatedAmount_not: BigDecimal
  delegatedAmount_gt: BigDecimal
  delegatedAmount_lt: BigDecimal
  delegatedAmount_gte: BigDecimal
  delegatedAmount_lte: BigDecimal
  delegatedAmount_in: [BigDecimal!]
  delegatedAmount_not_in: [BigDecimal!]
  unbondingLocks_: UnbondingLock_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Delegator_orderBy {
  id
  delegate
  startRound
  lastClaimRound
  bondedAmount
  principal
  unbonded
  fees
  withdrawnFees
  delegatedAmount
  unbondingLocks
}

"""
DepositFundedEvent entities are created for every emitted DepositFunded event.

"""
type DepositFundedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the broadcaster that deposited the broadcasting fees"""
  sender: Broadcaster!
  """Amount of broadcasting fees deposited"""
  amount: BigDecimal!
}

input DepositFundedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Broadcaster_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum DepositFundedEvent_orderBy {
  id
  transaction
  timestamp
  round
  sender
  amount
}

"""
EarningsClaimedEvent entities are created for every emitted EarningsClaimed event.

"""
type EarningsClaimedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegator that claimed its earnings"""
  delegator: Delegator!
  """Reference to the delegator's delegate"""
  delegate: Transcoder!
  """First round that the delegator's pending stake was computed from"""
  startRound: BigInt!
  """Last round that the delegator's pending stake was computed from"""
  endRound: Round!
  """Reward tokens claimed by the delegator"""
  rewardTokens: BigDecimal!
  """Fees claimed by the delegator"""
  fees: BigDecimal!
}

input EarningsClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  startRound: BigInt
  startRound_not: BigInt
  startRound_gt: BigInt
  startRound_lt: BigInt
  startRound_gte: BigInt
  startRound_lte: BigInt
  startRound_in: [BigInt!]
  startRound_not_in: [BigInt!]
  endRound: String
  endRound_not: String
  endRound_gt: String
  endRound_lt: String
  endRound_gte: String
  endRound_lte: String
  endRound_in: [String!]
  endRound_not_in: [String!]
  endRound_contains: String
  endRound_contains_nocase: String
  endRound_not_contains: String
  endRound_not_contains_nocase: String
  endRound_starts_with: String
  endRound_starts_with_nocase: String
  endRound_not_starts_with: String
  endRound_not_starts_with_nocase: String
  endRound_ends_with: String
  endRound_ends_with_nocase: String
  endRound_not_ends_with: String
  endRound_not_ends_with_nocase: String
  endRound_: Round_filter
  rewardTokens: BigDecimal
  rewardTokens_not: BigDecimal
  rewardTokens_gt: BigDecimal
  rewardTokens_lt: BigDecimal
  rewardTokens_gte: BigDecimal
  rewardTokens_lte: BigDecimal
  rewardTokens_in: [BigDecimal!]
  rewardTokens_not_in: [BigDecimal!]
  fees: BigDecimal
  fees_not: BigDecimal
  fees_gt: BigDecimal
  fees_lt: BigDecimal
  fees_gte: BigDecimal
  fees_lte: BigDecimal
  fees_in: [BigDecimal!]
  fees_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum EarningsClaimedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegator
  delegate
  startRound
  endRound
  rewardTokens
  fees
}

interface Event {
  id: ID!
  timestamp: Int!
  transaction: Transaction!
  round: Round!
}

input Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Event_orderBy {
  id
  timestamp
  transaction
  round
}

"""
MintEvent entities are created for every emitted Mint event.

"""
type MintEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Token smart contract address"""
  to: String!
  """Amount of tokens minted"""
  amount: BigDecimal!
}

input MintEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum MintEvent_orderBy {
  id
  transaction
  timestamp
  round
  to
  amount
}

"""
NewRoundEvent entities are created for every emitted NewRound event.

"""
type NewRoundEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Block hash for the round"""
  blockHash: String!
}

input NewRoundEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  blockHash: String
  blockHash_not: String
  blockHash_gt: String
  blockHash_lt: String
  blockHash_gte: String
  blockHash_lte: String
  blockHash_in: [String!]
  blockHash_not_in: [String!]
  blockHash_contains: String
  blockHash_contains_nocase: String
  blockHash_not_contains: String
  blockHash_not_contains_nocase: String
  blockHash_starts_with: String
  blockHash_starts_with_nocase: String
  blockHash_not_starts_with: String
  blockHash_not_starts_with_nocase: String
  blockHash_ends_with: String
  blockHash_ends_with_nocase: String
  blockHash_not_ends_with: String
  blockHash_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum NewRoundEvent_orderBy {
  id
  transaction
  timestamp
  round
  blockHash
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"""
ParameterUpdateEvent entities are created for every emitted ParameterUpdate event.

"""
type ParameterUpdateEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Parameter that was updated"""
  param: String!
}

input ParameterUpdateEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  param: String
  param_not: String
  param_gt: String
  param_lt: String
  param_gte: String
  param_lte: String
  param_in: [String!]
  param_not_in: [String!]
  param_contains: String
  param_contains_nocase: String
  param_not_contains: String
  param_not_contains_nocase: String
  param_starts_with: String
  param_starts_with_nocase: String
  param_not_starts_with: String
  param_not_starts_with_nocase: String
  param_ends_with: String
  param_ends_with_nocase: String
  param_not_ends_with: String
  param_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ParameterUpdateEvent_orderBy {
  id
  transaction
  timestamp
  round
  param
}

"""
PauseEvent entities are created for every emitted Pause event.

"""
type PauseEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
}

input PauseEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PauseEvent_orderBy {
  id
  transaction
  timestamp
  round
}

"""
Stake weighted poll

"""
type Poll {
  """Poll address"""
  id: ID!
  """IPFS multihash for the proposal"""
  proposal: String!
  """Block at which the poll ends and votes can no longer be submitted"""
  endBlock: BigInt!
  """
  Minimum amount of participation (total stake including inactive stake) required for a poll to pass
  """
  quorum: BigInt!
  """Minimum amount of yes votes required for a poll to pass"""
  quota: BigInt!
  """Poll tally"""
  tally: PollTally
  """Votes belonging to a poll"""
  votes(skip: Int = 0, first: Int = 100, orderBy: Vote_orderBy, orderDirection: OrderDirection, where: Vote_filter): [Vote!]
}

enum PollChoice {
  Yes
  No
}

"""
PollCreatedEvent entities are created for every emitted PollCreated event.

"""
type PollCreatedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the poll that was created"""
  poll: Poll!
  """IPFS content hash representing proposal"""
  proposal: Bytes!
  """Ethereum block in which this poll ends"""
  endBlock: BigInt!
  """
  The minimum amount of stake-weighted votes for this poll's outcome to be considered valid
  """
  quorum: BigInt!
  """
  The minimum amount of stake-weighted 'yes' votes needed for the poll to pass
  """
  quota: BigInt!
}

input PollCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  poll: String
  poll_not: String
  poll_gt: String
  poll_lt: String
  poll_gte: String
  poll_lte: String
  poll_in: [String!]
  poll_not_in: [String!]
  poll_contains: String
  poll_contains_nocase: String
  poll_not_contains: String
  poll_not_contains_nocase: String
  poll_starts_with: String
  poll_starts_with_nocase: String
  poll_not_starts_with: String
  poll_not_starts_with_nocase: String
  poll_ends_with: String
  poll_ends_with_nocase: String
  poll_not_ends_with: String
  poll_not_ends_with_nocase: String
  poll_: Poll_filter
  proposal: Bytes
  proposal_not: Bytes
  proposal_in: [Bytes!]
  proposal_not_in: [Bytes!]
  proposal_contains: Bytes
  proposal_not_contains: Bytes
  endBlock: BigInt
  endBlock_not: BigInt
  endBlock_gt: BigInt
  endBlock_lt: BigInt
  endBlock_gte: BigInt
  endBlock_lte: BigInt
  endBlock_in: [BigInt!]
  endBlock_not_in: [BigInt!]
  quorum: BigInt
  quorum_not: BigInt
  quorum_gt: BigInt
  quorum_lt: BigInt
  quorum_gte: BigInt
  quorum_lte: BigInt
  quorum_in: [BigInt!]
  quorum_not_in: [BigInt!]
  quota: BigInt
  quota_not: BigInt
  quota_gt: BigInt
  quota_lt: BigInt
  quota_gte: BigInt
  quota_lte: BigInt
  quota_in: [BigInt!]
  quota_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PollCreatedEvent_orderBy {
  id
  transaction
  timestamp
  round
  poll
  proposal
  endBlock
  quorum
  quota
}

"""
Stake weighted tally associated with a poll

"""
type PollTally {
  """Poll address"""
  id: ID!
  """Stake voted yes"""
  yes: BigDecimal
  """Stake voted no"""
  no: BigDecimal
}

input PollTally_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  yes: BigDecimal
  yes_not: BigDecimal
  yes_gt: BigDecimal
  yes_lt: BigDecimal
  yes_gte: BigDecimal
  yes_lte: BigDecimal
  yes_in: [BigDecimal!]
  yes_not_in: [BigDecimal!]
  no: BigDecimal
  no_not: BigDecimal
  no_gt: BigDecimal
  no_lt: BigDecimal
  no_gte: BigDecimal
  no_lte: BigDecimal
  no_in: [BigDecimal!]
  no_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PollTally_orderBy {
  id
  yes
  no
}

input Poll_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  proposal: String
  proposal_not: String
  proposal_gt: String
  proposal_lt: String
  proposal_gte: String
  proposal_lte: String
  proposal_in: [String!]
  proposal_not_in: [String!]
  proposal_contains: String
  proposal_contains_nocase: String
  proposal_not_contains: String
  proposal_not_contains_nocase: String
  proposal_starts_with: String
  proposal_starts_with_nocase: String
  proposal_not_starts_with: String
  proposal_not_starts_with_nocase: String
  proposal_ends_with: String
  proposal_ends_with_nocase: String
  proposal_not_ends_with: String
  proposal_not_ends_with_nocase: String
  endBlock: BigInt
  endBlock_not: BigInt
  endBlock_gt: BigInt
  endBlock_lt: BigInt
  endBlock_gte: BigInt
  endBlock_lte: BigInt
  endBlock_in: [BigInt!]
  endBlock_not_in: [BigInt!]
  quorum: BigInt
  quorum_not: BigInt
  quorum_gt: BigInt
  quorum_lt: BigInt
  quorum_gte: BigInt
  quorum_lte: BigInt
  quorum_in: [BigInt!]
  quorum_not_in: [BigInt!]
  quota: BigInt
  quota_not: BigInt
  quota_gt: BigInt
  quota_lt: BigInt
  quota_gte: BigInt
  quota_lte: BigInt
  quota_in: [BigInt!]
  quota_not_in: [BigInt!]
  tally: String
  tally_not: String
  tally_gt: String
  tally_lt: String
  tally_gte: String
  tally_lte: String
  tally_in: [String!]
  tally_not_in: [String!]
  tally_contains: String
  tally_contains_nocase: String
  tally_not_contains: String
  tally_not_contains_nocase: String
  tally_starts_with: String
  tally_starts_with_nocase: String
  tally_not_starts_with: String
  tally_not_starts_with_nocase: String
  tally_ends_with: String
  tally_ends_with_nocase: String
  tally_not_ends_with: String
  tally_not_ends_with_nocase: String
  tally_: PollTally_filter
  votes: [String!]
  votes_not: [String!]
  votes_contains: [String!]
  votes_contains_nocase: [String!]
  votes_not_contains: [String!]
  votes_not_contains_nocase: [String!]
  votes_: Vote_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Poll_orderBy {
  id
  proposal
  endBlock
  quorum
  quota
  tally
  votes
}

"""
Represents a transcoder's rewards and fees to be distributed to delegators

"""
type Pool {
  """
  Unique identifer for the pool (formed using the transcoder's address and round number)
  """
  id: ID!
  """Round associated with the pool"""
  round: Round!
  """Transcoder associated with the pool"""
  delegate: Transcoder!
  """Fees collected in the pool"""
  fees: BigDecimal
  """Total reward tokens collected in the pool"""
  rewardTokens: BigDecimal
  """Transcoder's total stake during the earnings pool's round"""
  totalStake: BigDecimal!
  """Transcoder's reward cut during the earnings pool's round"""
  rewardCut: BigInt!
  """Transcoder's fee share during the earnings pool's round"""
  feeShare: BigInt!
}

input Pool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  fees: BigDecimal
  fees_not: BigDecimal
  fees_gt: BigDecimal
  fees_lt: BigDecimal
  fees_gte: BigDecimal
  fees_lte: BigDecimal
  fees_in: [BigDecimal!]
  fees_not_in: [BigDecimal!]
  rewardTokens: BigDecimal
  rewardTokens_not: BigDecimal
  rewardTokens_gt: BigDecimal
  rewardTokens_lt: BigDecimal
  rewardTokens_gte: BigDecimal
  rewardTokens_lte: BigDecimal
  rewardTokens_in: [BigDecimal!]
  rewardTokens_not_in: [BigDecimal!]
  totalStake: BigDecimal
  totalStake_not: BigDecimal
  totalStake_gt: BigDecimal
  totalStake_lt: BigDecimal
  totalStake_gte: BigDecimal
  totalStake_lte: BigDecimal
  totalStake_in: [BigDecimal!]
  totalStake_not_in: [BigDecimal!]
  rewardCut: BigInt
  rewardCut_not: BigInt
  rewardCut_gt: BigInt
  rewardCut_lt: BigInt
  rewardCut_gte: BigInt
  rewardCut_lte: BigInt
  rewardCut_in: [BigInt!]
  rewardCut_not_in: [BigInt!]
  feeShare: BigInt
  feeShare_not: BigInt
  feeShare_gt: BigInt
  feeShare_lt: BigInt
  feeShare_gte: BigInt
  feeShare_lte: BigInt
  feeShare_in: [BigInt!]
  feeShare_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Pool_orderBy {
  id
  round
  delegate
  fees
  rewardTokens
  totalStake
  rewardCut
  feeShare
}

"""
Livepeer protocol global parameters

"""
type Protocol {
  """ID is set to 0"""
  id: ID!
  """Per round inflation rate"""
  inflation: BigInt!
  """
  Change in inflation rate per round until the target bonding rate is achieved
  """
  inflationChange: BigInt!
  """Max number of rounds that a caller can claim earnings for at once"""
  maxEarningsClaimsRounds: Int!
  """Total active transcoders"""
  numActiveTranscoders: Int!
  """True if the protocol is paused"""
  paused: Boolean!
  """
  Target bonding rate (participation) that determines whether inflation should increase or decrease
  """
  targetBondingRate: BigInt!
  """Time in blocks needed to wait to unstake"""
  unbondingPeriod: BigInt!
  """
  Time in blocks delegators have to review transcoder information without changes
  """
  lockPeriod: BigInt!
  """Lock period of a round as a % of round length"""
  roundLockAmount: BigInt!
  """The total amount of active LPT staked"""
  totalActiveStake: BigDecimal!
  """Total broadcaster fees transcoders have accumulated in ETH"""
  totalVolumeETH: BigDecimal!
  """Total broadcaster fees transcoders have accumulated in USD"""
  totalVolumeUSD: BigDecimal!
  """Ratio of total active stake to total supply"""
  participationRate: BigDecimal!
  """Current round the protocol is in"""
  currentRound: Round
  """Round that was last initialized"""
  lastInitializedRound: Round
  """Round when round length was last updated"""
  lastRoundLengthUpdateRound: Round
  """Round length in blocks"""
  roundLength: BigInt!
  """Block when round length was last updated"""
  lastRoundLengthUpdateStartBlock: BigInt!
  """Livepeer Token supply"""
  totalSupply: BigDecimal!
  """Total winning tickets"""
  winningTicketCount: Int!
  """Total rounds"""
  roundCount: Int!
  """Transcoders pending activation"""
  pendingActivation(skip: Int = 0, first: Int = 100, orderBy: Transcoder_orderBy, orderDirection: OrderDirection, where: Transcoder_filter): [Transcoder!]!
  """Transcoders pending deactivation"""
  pendingDeactivation(skip: Int = 0, first: Int = 100, orderBy: Transcoder_orderBy, orderDirection: OrderDirection, where: Transcoder_filter): [Transcoder!]!
}

input Protocol_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  inflation: BigInt
  inflation_not: BigInt
  inflation_gt: BigInt
  inflation_lt: BigInt
  inflation_gte: BigInt
  inflation_lte: BigInt
  inflation_in: [BigInt!]
  inflation_not_in: [BigInt!]
  inflationChange: BigInt
  inflationChange_not: BigInt
  inflationChange_gt: BigInt
  inflationChange_lt: BigInt
  inflationChange_gte: BigInt
  inflationChange_lte: BigInt
  inflationChange_in: [BigInt!]
  inflationChange_not_in: [BigInt!]
  maxEarningsClaimsRounds: Int
  maxEarningsClaimsRounds_not: Int
  maxEarningsClaimsRounds_gt: Int
  maxEarningsClaimsRounds_lt: Int
  maxEarningsClaimsRounds_gte: Int
  maxEarningsClaimsRounds_lte: Int
  maxEarningsClaimsRounds_in: [Int!]
  maxEarningsClaimsRounds_not_in: [Int!]
  numActiveTranscoders: Int
  numActiveTranscoders_not: Int
  numActiveTranscoders_gt: Int
  numActiveTranscoders_lt: Int
  numActiveTranscoders_gte: Int
  numActiveTranscoders_lte: Int
  numActiveTranscoders_in: [Int!]
  numActiveTranscoders_not_in: [Int!]
  paused: Boolean
  paused_not: Boolean
  paused_in: [Boolean!]
  paused_not_in: [Boolean!]
  targetBondingRate: BigInt
  targetBondingRate_not: BigInt
  targetBondingRate_gt: BigInt
  targetBondingRate_lt: BigInt
  targetBondingRate_gte: BigInt
  targetBondingRate_lte: BigInt
  targetBondingRate_in: [BigInt!]
  targetBondingRate_not_in: [BigInt!]
  unbondingPeriod: BigInt
  unbondingPeriod_not: BigInt
  unbondingPeriod_gt: BigInt
  unbondingPeriod_lt: BigInt
  unbondingPeriod_gte: BigInt
  unbondingPeriod_lte: BigInt
  unbondingPeriod_in: [BigInt!]
  unbondingPeriod_not_in: [BigInt!]
  lockPeriod: BigInt
  lockPeriod_not: BigInt
  lockPeriod_gt: BigInt
  lockPeriod_lt: BigInt
  lockPeriod_gte: BigInt
  lockPeriod_lte: BigInt
  lockPeriod_in: [BigInt!]
  lockPeriod_not_in: [BigInt!]
  roundLockAmount: BigInt
  roundLockAmount_not: BigInt
  roundLockAmount_gt: BigInt
  roundLockAmount_lt: BigInt
  roundLockAmount_gte: BigInt
  roundLockAmount_lte: BigInt
  roundLockAmount_in: [BigInt!]
  roundLockAmount_not_in: [BigInt!]
  totalActiveStake: BigDecimal
  totalActiveStake_not: BigDecimal
  totalActiveStake_gt: BigDecimal
  totalActiveStake_lt: BigDecimal
  totalActiveStake_gte: BigDecimal
  totalActiveStake_lte: BigDecimal
  totalActiveStake_in: [BigDecimal!]
  totalActiveStake_not_in: [BigDecimal!]
  totalVolumeETH: BigDecimal
  totalVolumeETH_not: BigDecimal
  totalVolumeETH_gt: BigDecimal
  totalVolumeETH_lt: BigDecimal
  totalVolumeETH_gte: BigDecimal
  totalVolumeETH_lte: BigDecimal
  totalVolumeETH_in: [BigDecimal!]
  totalVolumeETH_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_not_in: [BigDecimal!]
  participationRate: BigDecimal
  participationRate_not: BigDecimal
  participationRate_gt: BigDecimal
  participationRate_lt: BigDecimal
  participationRate_gte: BigDecimal
  participationRate_lte: BigDecimal
  participationRate_in: [BigDecimal!]
  participationRate_not_in: [BigDecimal!]
  currentRound: String
  currentRound_not: String
  currentRound_gt: String
  currentRound_lt: String
  currentRound_gte: String
  currentRound_lte: String
  currentRound_in: [String!]
  currentRound_not_in: [String!]
  currentRound_contains: String
  currentRound_contains_nocase: String
  currentRound_not_contains: String
  currentRound_not_contains_nocase: String
  currentRound_starts_with: String
  currentRound_starts_with_nocase: String
  currentRound_not_starts_with: String
  currentRound_not_starts_with_nocase: String
  currentRound_ends_with: String
  currentRound_ends_with_nocase: String
  currentRound_not_ends_with: String
  currentRound_not_ends_with_nocase: String
  currentRound_: Round_filter
  lastInitializedRound: String
  lastInitializedRound_not: String
  lastInitializedRound_gt: String
  lastInitializedRound_lt: String
  lastInitializedRound_gte: String
  lastInitializedRound_lte: String
  lastInitializedRound_in: [String!]
  lastInitializedRound_not_in: [String!]
  lastInitializedRound_contains: String
  lastInitializedRound_contains_nocase: String
  lastInitializedRound_not_contains: String
  lastInitializedRound_not_contains_nocase: String
  lastInitializedRound_starts_with: String
  lastInitializedRound_starts_with_nocase: String
  lastInitializedRound_not_starts_with: String
  lastInitializedRound_not_starts_with_nocase: String
  lastInitializedRound_ends_with: String
  lastInitializedRound_ends_with_nocase: String
  lastInitializedRound_not_ends_with: String
  lastInitializedRound_not_ends_with_nocase: String
  lastInitializedRound_: Round_filter
  lastRoundLengthUpdateRound: String
  lastRoundLengthUpdateRound_not: String
  lastRoundLengthUpdateRound_gt: String
  lastRoundLengthUpdateRound_lt: String
  lastRoundLengthUpdateRound_gte: String
  lastRoundLengthUpdateRound_lte: String
  lastRoundLengthUpdateRound_in: [String!]
  lastRoundLengthUpdateRound_not_in: [String!]
  lastRoundLengthUpdateRound_contains: String
  lastRoundLengthUpdateRound_contains_nocase: String
  lastRoundLengthUpdateRound_not_contains: String
  lastRoundLengthUpdateRound_not_contains_nocase: String
  lastRoundLengthUpdateRound_starts_with: String
  lastRoundLengthUpdateRound_starts_with_nocase: String
  lastRoundLengthUpdateRound_not_starts_with: String
  lastRoundLengthUpdateRound_not_starts_with_nocase: String
  lastRoundLengthUpdateRound_ends_with: String
  lastRoundLengthUpdateRound_ends_with_nocase: String
  lastRoundLengthUpdateRound_not_ends_with: String
  lastRoundLengthUpdateRound_not_ends_with_nocase: String
  lastRoundLengthUpdateRound_: Round_filter
  roundLength: BigInt
  roundLength_not: BigInt
  roundLength_gt: BigInt
  roundLength_lt: BigInt
  roundLength_gte: BigInt
  roundLength_lte: BigInt
  roundLength_in: [BigInt!]
  roundLength_not_in: [BigInt!]
  lastRoundLengthUpdateStartBlock: BigInt
  lastRoundLengthUpdateStartBlock_not: BigInt
  lastRoundLengthUpdateStartBlock_gt: BigInt
  lastRoundLengthUpdateStartBlock_lt: BigInt
  lastRoundLengthUpdateStartBlock_gte: BigInt
  lastRoundLengthUpdateStartBlock_lte: BigInt
  lastRoundLengthUpdateStartBlock_in: [BigInt!]
  lastRoundLengthUpdateStartBlock_not_in: [BigInt!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  winningTicketCount: Int
  winningTicketCount_not: Int
  winningTicketCount_gt: Int
  winningTicketCount_lt: Int
  winningTicketCount_gte: Int
  winningTicketCount_lte: Int
  winningTicketCount_in: [Int!]
  winningTicketCount_not_in: [Int!]
  roundCount: Int
  roundCount_not: Int
  roundCount_gt: Int
  roundCount_lt: Int
  roundCount_gte: Int
  roundCount_lte: Int
  roundCount_in: [Int!]
  roundCount_not_in: [Int!]
  pendingActivation: [String!]
  pendingActivation_not: [String!]
  pendingActivation_contains: [String!]
  pendingActivation_contains_nocase: [String!]
  pendingActivation_not_contains: [String!]
  pendingActivation_not_contains_nocase: [String!]
  pendingActivation_: Transcoder_filter
  pendingDeactivation: [String!]
  pendingDeactivation_not: [String!]
  pendingDeactivation_contains: [String!]
  pendingDeactivation_contains_nocase: [String!]
  pendingDeactivation_not_contains: [String!]
  pendingDeactivation_not_contains_nocase: [String!]
  pendingDeactivation_: Transcoder_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Protocol_orderBy {
  id
  inflation
  inflationChange
  maxEarningsClaimsRounds
  numActiveTranscoders
  paused
  targetBondingRate
  unbondingPeriod
  lockPeriod
  roundLockAmount
  totalActiveStake
  totalVolumeETH
  totalVolumeUSD
  participationRate
  currentRound
  lastInitializedRound
  lastRoundLengthUpdateRound
  roundLength
  lastRoundLengthUpdateStartBlock
  totalSupply
  winningTicketCount
  roundCount
  pendingActivation
  pendingDeactivation
}

"""
RebondEvent entities are created for every emitted Rebond event.

"""
type RebondEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegator that rebonded"""
  delegator: Delegator!
  delegate: Transcoder!
  amount: BigDecimal!
  unbondingLockId: Int!
}

input RebondEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  unbondingLockId: Int
  unbondingLockId_not: Int
  unbondingLockId_gt: Int
  unbondingLockId_lt: Int
  unbondingLockId_gte: Int
  unbondingLockId_lte: Int
  unbondingLockId_in: [Int!]
  unbondingLockId_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RebondEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegator
  delegate
  amount
  unbondingLockId
}

"""
ReserveClaimedEvent entities are created for every emitted ReserveClaimed event.

"""
type ReserveClaimedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the reserve holder"""
  reserveHolder: Broadcaster!
  """Reference to the claimant"""
  claimant: Transcoder!
  """
  Amount of funds claimed by claimant from the reserve for the reserve holder
  """
  amount: BigDecimal!
}

input ReserveClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  reserveHolder: String
  reserveHolder_not: String
  reserveHolder_gt: String
  reserveHolder_lt: String
  reserveHolder_gte: String
  reserveHolder_lte: String
  reserveHolder_in: [String!]
  reserveHolder_not_in: [String!]
  reserveHolder_contains: String
  reserveHolder_contains_nocase: String
  reserveHolder_not_contains: String
  reserveHolder_not_contains_nocase: String
  reserveHolder_starts_with: String
  reserveHolder_starts_with_nocase: String
  reserveHolder_not_starts_with: String
  reserveHolder_not_starts_with_nocase: String
  reserveHolder_ends_with: String
  reserveHolder_ends_with_nocase: String
  reserveHolder_not_ends_with: String
  reserveHolder_not_ends_with_nocase: String
  reserveHolder_: Broadcaster_filter
  claimant: String
  claimant_not: String
  claimant_gt: String
  claimant_lt: String
  claimant_gte: String
  claimant_lte: String
  claimant_in: [String!]
  claimant_not_in: [String!]
  claimant_contains: String
  claimant_contains_nocase: String
  claimant_not_contains: String
  claimant_not_contains_nocase: String
  claimant_starts_with: String
  claimant_starts_with_nocase: String
  claimant_not_starts_with: String
  claimant_not_starts_with_nocase: String
  claimant_ends_with: String
  claimant_ends_with_nocase: String
  claimant_not_ends_with: String
  claimant_not_ends_with_nocase: String
  claimant_: Transcoder_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ReserveClaimedEvent_orderBy {
  id
  transaction
  timestamp
  round
  reserveHolder
  claimant
  amount
}

"""
ReserveFundedEvent entities are created for every emitted ReserveFunded event.

"""
type ReserveFundedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to reserve holder"""
  reserveHolder: Broadcaster!
  """Amount of funds added to reserve"""
  amount: BigDecimal!
}

input ReserveFundedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  reserveHolder: String
  reserveHolder_not: String
  reserveHolder_gt: String
  reserveHolder_lt: String
  reserveHolder_gte: String
  reserveHolder_lte: String
  reserveHolder_in: [String!]
  reserveHolder_not_in: [String!]
  reserveHolder_contains: String
  reserveHolder_contains_nocase: String
  reserveHolder_not_contains: String
  reserveHolder_not_contains_nocase: String
  reserveHolder_starts_with: String
  reserveHolder_starts_with_nocase: String
  reserveHolder_not_starts_with: String
  reserveHolder_not_starts_with_nocase: String
  reserveHolder_ends_with: String
  reserveHolder_ends_with_nocase: String
  reserveHolder_not_ends_with: String
  reserveHolder_not_ends_with_nocase: String
  reserveHolder_: Broadcaster_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ReserveFundedEvent_orderBy {
  id
  transaction
  timestamp
  round
  reserveHolder
  amount
}

"""
RewardEvent entities are created for every emitted Reward event.

"""
type RewardEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Amount of inflationary token rewards claimed"""
  rewardTokens: BigDecimal!
  """Reference to the delegate that claimed its inflationary token reward"""
  delegate: Transcoder!
}

input RewardEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  rewardTokens: BigDecimal
  rewardTokens_not: BigDecimal
  rewardTokens_gt: BigDecimal
  rewardTokens_lt: BigDecimal
  rewardTokens_gte: BigDecimal
  rewardTokens_lte: BigDecimal
  rewardTokens_in: [BigDecimal!]
  rewardTokens_not_in: [BigDecimal!]
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RewardEvent_orderBy {
  id
  transaction
  timestamp
  round
  rewardTokens
  delegate
}

"""
The Livepeer protocol is round based and each round is represented by some number of Ethereum blocks.

"""
type Round {
  """Round number"""
  id: ID!
  """Whether the round was initialized"""
  initialized: Boolean!
  """Number of blocks this round lasts for"""
  length: BigInt!
  """Start block for the round"""
  startBlock: BigInt!
  """End block for the round"""
  endBlock: BigInt!
  """Pools associated with the round"""
  pools(skip: Int = 0, first: Int = 100, orderBy: Pool_orderBy, orderDirection: OrderDirection, where: Pool_filter): [Pool!]
  """Mintable tokens for the round"""
  mintableTokens: BigDecimal!
  """Fees generated this round in ETH"""
  volumeETH: BigDecimal!
  """Fees generated this round in USD"""
  volumeUSD: BigDecimal!
  """Total active stake during the round"""
  totalActiveStake: BigDecimal!
  """Total Livepeer token supply during the round"""
  totalSupply: BigDecimal!
  """Participation rate during the round (totalActiveStake/totalSupply)"""
  participationRate: BigDecimal!
  """Total stake moved from one delegate to another during the round"""
  movedStake: BigDecimal!
  """Total amount of new stake introduced during the round"""
  newStake: BigDecimal!
}

input Round_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  initialized: Boolean
  initialized_not: Boolean
  initialized_in: [Boolean!]
  initialized_not_in: [Boolean!]
  length: BigInt
  length_not: BigInt
  length_gt: BigInt
  length_lt: BigInt
  length_gte: BigInt
  length_lte: BigInt
  length_in: [BigInt!]
  length_not_in: [BigInt!]
  startBlock: BigInt
  startBlock_not: BigInt
  startBlock_gt: BigInt
  startBlock_lt: BigInt
  startBlock_gte: BigInt
  startBlock_lte: BigInt
  startBlock_in: [BigInt!]
  startBlock_not_in: [BigInt!]
  endBlock: BigInt
  endBlock_not: BigInt
  endBlock_gt: BigInt
  endBlock_lt: BigInt
  endBlock_gte: BigInt
  endBlock_lte: BigInt
  endBlock_in: [BigInt!]
  endBlock_not_in: [BigInt!]
  pools_: Pool_filter
  mintableTokens: BigDecimal
  mintableTokens_not: BigDecimal
  mintableTokens_gt: BigDecimal
  mintableTokens_lt: BigDecimal
  mintableTokens_gte: BigDecimal
  mintableTokens_lte: BigDecimal
  mintableTokens_in: [BigDecimal!]
  mintableTokens_not_in: [BigDecimal!]
  volumeETH: BigDecimal
  volumeETH_not: BigDecimal
  volumeETH_gt: BigDecimal
  volumeETH_lt: BigDecimal
  volumeETH_gte: BigDecimal
  volumeETH_lte: BigDecimal
  volumeETH_in: [BigDecimal!]
  volumeETH_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  totalActiveStake: BigDecimal
  totalActiveStake_not: BigDecimal
  totalActiveStake_gt: BigDecimal
  totalActiveStake_lt: BigDecimal
  totalActiveStake_gte: BigDecimal
  totalActiveStake_lte: BigDecimal
  totalActiveStake_in: [BigDecimal!]
  totalActiveStake_not_in: [BigDecimal!]
  totalSupply: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_lt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_not_in: [BigDecimal!]
  participationRate: BigDecimal
  participationRate_not: BigDecimal
  participationRate_gt: BigDecimal
  participationRate_lt: BigDecimal
  participationRate_gte: BigDecimal
  participationRate_lte: BigDecimal
  participationRate_in: [BigDecimal!]
  participationRate_not_in: [BigDecimal!]
  movedStake: BigDecimal
  movedStake_not: BigDecimal
  movedStake_gt: BigDecimal
  movedStake_lt: BigDecimal
  movedStake_gte: BigDecimal
  movedStake_lte: BigDecimal
  movedStake_in: [BigDecimal!]
  movedStake_not_in: [BigDecimal!]
  newStake: BigDecimal
  newStake_not: BigDecimal
  newStake_gt: BigDecimal
  newStake_lt: BigDecimal
  newStake_gte: BigDecimal
  newStake_lte: BigDecimal
  newStake_in: [BigDecimal!]
  newStake_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Round_orderBy {
  id
  initialized
  length
  startBlock
  endBlock
  pools
  mintableTokens
  volumeETH
  volumeUSD
  totalActiveStake
  totalSupply
  participationRate
  movedStake
  newStake
}

"""
ServiceURIUpdateEvent entities are created for every emitted ServiceURIUpdate event.

"""
type ServiceURIUpdateEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Address of sender"""
  addr: String!
  """Service URI endpoint for the caller"""
  serviceURI: String!
}

input ServiceURIUpdateEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  addr: String
  addr_not: String
  addr_gt: String
  addr_lt: String
  addr_gte: String
  addr_lte: String
  addr_in: [String!]
  addr_not_in: [String!]
  addr_contains: String
  addr_contains_nocase: String
  addr_not_contains: String
  addr_not_contains_nocase: String
  addr_starts_with: String
  addr_starts_with_nocase: String
  addr_not_starts_with: String
  addr_not_starts_with_nocase: String
  addr_ends_with: String
  addr_ends_with_nocase: String
  addr_not_ends_with: String
  addr_not_ends_with_nocase: String
  serviceURI: String
  serviceURI_not: String
  serviceURI_gt: String
  serviceURI_lt: String
  serviceURI_gte: String
  serviceURI_lte: String
  serviceURI_in: [String!]
  serviceURI_not_in: [String!]
  serviceURI_contains: String
  serviceURI_contains_nocase: String
  serviceURI_not_contains: String
  serviceURI_not_contains_nocase: String
  serviceURI_starts_with: String
  serviceURI_starts_with_nocase: String
  serviceURI_not_starts_with: String
  serviceURI_not_starts_with_nocase: String
  serviceURI_ends_with: String
  serviceURI_ends_with_nocase: String
  serviceURI_not_ends_with: String
  serviceURI_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ServiceURIUpdateEvent_orderBy {
  id
  transaction
  timestamp
  round
  addr
  serviceURI
}

"""
SetCurrentRewardTokensEvent entities are created for every emitted SetCurrentRewardTokens event.

"""
type SetCurrentRewardTokensEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Number of mintable tokens for the round"""
  currentMintableTokens: BigDecimal!
  """Current inflation during the round"""
  currentInflation: BigInt!
}

input SetCurrentRewardTokensEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  currentMintableTokens: BigDecimal
  currentMintableTokens_not: BigDecimal
  currentMintableTokens_gt: BigDecimal
  currentMintableTokens_lt: BigDecimal
  currentMintableTokens_gte: BigDecimal
  currentMintableTokens_lte: BigDecimal
  currentMintableTokens_in: [BigDecimal!]
  currentMintableTokens_not_in: [BigDecimal!]
  currentInflation: BigInt
  currentInflation_not: BigInt
  currentInflation_gt: BigInt
  currentInflation_lt: BigInt
  currentInflation_gte: BigInt
  currentInflation_lte: BigInt
  currentInflation_in: [BigInt!]
  currentInflation_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SetCurrentRewardTokensEvent_orderBy {
  id
  transaction
  timestamp
  round
  currentMintableTokens
  currentInflation
}

"""
Transaction entities are created for each Ethereum transaction that contains an interaction within Livepeer contracts.

"""
type Transaction {
  """Ethereum transaction hash"""
  id: ID!
  """Block transaction was mined in"""
  blockNumber: BigInt!
  """Timestamp for transaction"""
  timestamp: Int!
  """Amount of gas used in the transaction"""
  gasUsed: BigInt!
  """Cost per unit of gas specified for the transaction"""
  gasPrice: BigInt!
  """The sending party of the transaction"""
  from: String!
  """The receiving party of the transaction"""
  to: String!
  """The events emitted within this transaction"""
  events(skip: Int = 0, first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, where: Event_filter): [Event!]
}

input Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Transaction_orderBy {
  id
  blockNumber
  timestamp
  gasUsed
  gasPrice
  from
  to
  events
}

"""
Perform transcoding work for the network. The transcoders with the most delegated stake are elected as active transcoders that process transcode jobs for the network.

"""
type Transcoder {
  """Transcoder's ETH address"""
  id: ID!
  """Round in which the transcoder became active - 0 if inactive"""
  activationRound: BigInt!
  """Round in which the transcoder will become inactive"""
  deactivationRound: BigInt!
  """
  Round for which the stake was last updated while the transcoder is active
  """
  lastActiveStakeUpdateRound: BigInt!
  """Whether or not the transcoder is active"""
  active: Boolean!
  """Status of the transcoder"""
  status: TranscoderStatus!
  """Last round that the transcoder called reward"""
  lastRewardRound: Round
  """% of block reward cut paid to transcoder by a delegator"""
  rewardCut: BigInt!
  """% of fees paid to delegators by transcoder"""
  feeShare: BigInt!
  """Price per segment for a stream"""
  pricePerSegment: BigInt
  """Pending price per segment for next round if the transcoder is active"""
  pendingPricePerSegment: BigInt
  """Pending block reward cut for next round if the transcoder is active"""
  pendingRewardCut: BigInt
  """Pending fee share for next round if the transcoder is active"""
  pendingFeeShare: BigInt
  """Total tokens delegated toward a transcoder (including their own)"""
  totalStake: BigDecimal!
  """
  Total fees generated by the transcoder in ETH (before distribution to delegators)
  """
  totalVolumeETH: BigDecimal!
  """
  Total fees generated by the transcoder in USD (before distribution to delegators)
  """
  totalVolumeUSD: BigDecimal!
  """Pools associated with the transcoder"""
  pools(skip: Int = 0, first: Int = 100, orderBy: Pool_orderBy, orderDirection: OrderDirection, where: Pool_filter): [Pool!]
  """Delegators bonded to the transcoder"""
  delegators(skip: Int = 0, first: Int = 100, orderBy: Delegator_orderBy, orderDirection: OrderDirection, where: Delegator_filter): [Delegator!]
  """Delegator that registered this transcoder"""
  delegator: Delegator
  """Service URI endpoint that can be used to send off-chain requests"""
  serviceURI: String
}

"""
TranscoderActivatedEvent entities are created for every emitted TranscoderActivated event.

"""
type TranscoderActivatedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that will be active"""
  delegate: Transcoder!
  """Future round in which the delegate will become active"""
  activationRound: BigInt!
}

input TranscoderActivatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  activationRound: BigInt
  activationRound_not: BigInt
  activationRound_gt: BigInt
  activationRound_lt: BigInt
  activationRound_gte: BigInt
  activationRound_lte: BigInt
  activationRound_in: [BigInt!]
  activationRound_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderActivatedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
  activationRound
}

"""
Transcoder data accumulated and condensed into day stats

"""
type TranscoderDay {
  """
  Combination of the transcoder address and the timestamp rounded to current day by dividing by 86400
  """
  id: ID!
  """The date beginning at 12:00am UTC"""
  date: Int!
  """Fees generated this day in ETH"""
  volumeETH: BigDecimal!
  """Fees generated this day in USD"""
  volumeUSD: BigDecimal!
  """Transcoder associated with the day"""
  transcoder: Transcoder!
}

input TranscoderDay_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  volumeETH: BigDecimal
  volumeETH_not: BigDecimal
  volumeETH_gt: BigDecimal
  volumeETH_lt: BigDecimal
  volumeETH_gte: BigDecimal
  volumeETH_lte: BigDecimal
  volumeETH_in: [BigDecimal!]
  volumeETH_not_in: [BigDecimal!]
  volumeUSD: BigDecimal
  volumeUSD_not: BigDecimal
  volumeUSD_gt: BigDecimal
  volumeUSD_lt: BigDecimal
  volumeUSD_gte: BigDecimal
  volumeUSD_lte: BigDecimal
  volumeUSD_in: [BigDecimal!]
  volumeUSD_not_in: [BigDecimal!]
  transcoder: String
  transcoder_not: String
  transcoder_gt: String
  transcoder_lt: String
  transcoder_gte: String
  transcoder_lte: String
  transcoder_in: [String!]
  transcoder_not_in: [String!]
  transcoder_contains: String
  transcoder_contains_nocase: String
  transcoder_not_contains: String
  transcoder_not_contains_nocase: String
  transcoder_starts_with: String
  transcoder_starts_with_nocase: String
  transcoder_not_starts_with: String
  transcoder_not_starts_with_nocase: String
  transcoder_ends_with: String
  transcoder_ends_with_nocase: String
  transcoder_not_ends_with: String
  transcoder_not_ends_with_nocase: String
  transcoder_: Transcoder_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderDay_orderBy {
  id
  date
  volumeETH
  volumeUSD
  transcoder
}

"""
TranscoderDeactivatedEvent entities are created for every emitted TranscoderDeactivated event.

"""
type TranscoderDeactivatedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that will become deactive"""
  delegate: Transcoder!
  """Future round in which the delegate will become deactive"""
  deactivationRound: BigInt!
}

input TranscoderDeactivatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  deactivationRound: BigInt
  deactivationRound_not: BigInt
  deactivationRound_gt: BigInt
  deactivationRound_lt: BigInt
  deactivationRound_gte: BigInt
  deactivationRound_lte: BigInt
  deactivationRound_in: [BigInt!]
  deactivationRound_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderDeactivatedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
  deactivationRound
}

"""
TranscoderEvictedEvent entities are created for every emitted TranscoderEvicted event.

"""
type TranscoderEvictedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that was evicted"""
  delegate: Transcoder!
}

input TranscoderEvictedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderEvictedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
}

"""
TranscoderResignedEvent entities are created for every emitted TranscoderResigned event.

"""
type TranscoderResignedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that resigned"""
  delegate: Transcoder!
}

input TranscoderResignedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderResignedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
}

"""
TranscoderSlashedEvent entities are created for every emitted TranscoderSlashed event.

"""
type TranscoderSlashedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that was slashed"""
  delegate: Transcoder!
  """
  Finder that proved a transcoder violated a slashing condition. Null address if there is no finder
  """
  finder: Bytes!
  """Percentage of transcoder bond to be slashed"""
  penalty: BigDecimal!
  """Percentage of penalty awarded to finder. Zero if there is no finder"""
  finderReward: BigInt!
}

input TranscoderSlashedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  finder: Bytes
  finder_not: Bytes
  finder_in: [Bytes!]
  finder_not_in: [Bytes!]
  finder_contains: Bytes
  finder_not_contains: Bytes
  penalty: BigDecimal
  penalty_not: BigDecimal
  penalty_gt: BigDecimal
  penalty_lt: BigDecimal
  penalty_gte: BigDecimal
  penalty_lte: BigDecimal
  penalty_in: [BigDecimal!]
  penalty_not_in: [BigDecimal!]
  finderReward: BigInt
  finderReward_not: BigInt
  finderReward_gt: BigInt
  finderReward_lt: BigInt
  finderReward_gte: BigInt
  finderReward_lte: BigInt
  finderReward_in: [BigInt!]
  finderReward_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderSlashedEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
  finder
  penalty
  finderReward
}

enum TranscoderStatus {
  NotRegistered
  Registered
}

"""
TranscoderUpdateEvent entities are created for every emitted TranscoderUpdate event.

"""
type TranscoderUpdateEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegate that was updated"""
  delegate: Transcoder!
  """Delegate's updated reward cut"""
  rewardCut: BigInt!
  """Delegate's updated fee share"""
  feeShare: BigInt!
}

input TranscoderUpdateEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  rewardCut: BigInt
  rewardCut_not: BigInt
  rewardCut_gt: BigInt
  rewardCut_lt: BigInt
  rewardCut_gte: BigInt
  rewardCut_lte: BigInt
  rewardCut_in: [BigInt!]
  rewardCut_not_in: [BigInt!]
  feeShare: BigInt
  feeShare_not: BigInt
  feeShare_gt: BigInt
  feeShare_lt: BigInt
  feeShare_gte: BigInt
  feeShare_lte: BigInt
  feeShare_in: [BigInt!]
  feeShare_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TranscoderUpdateEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegate
  rewardCut
  feeShare
}

input Transcoder_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  activationRound: BigInt
  activationRound_not: BigInt
  activationRound_gt: BigInt
  activationRound_lt: BigInt
  activationRound_gte: BigInt
  activationRound_lte: BigInt
  activationRound_in: [BigInt!]
  activationRound_not_in: [BigInt!]
  deactivationRound: BigInt
  deactivationRound_not: BigInt
  deactivationRound_gt: BigInt
  deactivationRound_lt: BigInt
  deactivationRound_gte: BigInt
  deactivationRound_lte: BigInt
  deactivationRound_in: [BigInt!]
  deactivationRound_not_in: [BigInt!]
  lastActiveStakeUpdateRound: BigInt
  lastActiveStakeUpdateRound_not: BigInt
  lastActiveStakeUpdateRound_gt: BigInt
  lastActiveStakeUpdateRound_lt: BigInt
  lastActiveStakeUpdateRound_gte: BigInt
  lastActiveStakeUpdateRound_lte: BigInt
  lastActiveStakeUpdateRound_in: [BigInt!]
  lastActiveStakeUpdateRound_not_in: [BigInt!]
  active: Boolean
  active_not: Boolean
  active_in: [Boolean!]
  active_not_in: [Boolean!]
  status: TranscoderStatus
  status_not: TranscoderStatus
  status_in: [TranscoderStatus!]
  status_not_in: [TranscoderStatus!]
  lastRewardRound: String
  lastRewardRound_not: String
  lastRewardRound_gt: String
  lastRewardRound_lt: String
  lastRewardRound_gte: String
  lastRewardRound_lte: String
  lastRewardRound_in: [String!]
  lastRewardRound_not_in: [String!]
  lastRewardRound_contains: String
  lastRewardRound_contains_nocase: String
  lastRewardRound_not_contains: String
  lastRewardRound_not_contains_nocase: String
  lastRewardRound_starts_with: String
  lastRewardRound_starts_with_nocase: String
  lastRewardRound_not_starts_with: String
  lastRewardRound_not_starts_with_nocase: String
  lastRewardRound_ends_with: String
  lastRewardRound_ends_with_nocase: String
  lastRewardRound_not_ends_with: String
  lastRewardRound_not_ends_with_nocase: String
  lastRewardRound_: Round_filter
  rewardCut: BigInt
  rewardCut_not: BigInt
  rewardCut_gt: BigInt
  rewardCut_lt: BigInt
  rewardCut_gte: BigInt
  rewardCut_lte: BigInt
  rewardCut_in: [BigInt!]
  rewardCut_not_in: [BigInt!]
  feeShare: BigInt
  feeShare_not: BigInt
  feeShare_gt: BigInt
  feeShare_lt: BigInt
  feeShare_gte: BigInt
  feeShare_lte: BigInt
  feeShare_in: [BigInt!]
  feeShare_not_in: [BigInt!]
  pricePerSegment: BigInt
  pricePerSegment_not: BigInt
  pricePerSegment_gt: BigInt
  pricePerSegment_lt: BigInt
  pricePerSegment_gte: BigInt
  pricePerSegment_lte: BigInt
  pricePerSegment_in: [BigInt!]
  pricePerSegment_not_in: [BigInt!]
  pendingPricePerSegment: BigInt
  pendingPricePerSegment_not: BigInt
  pendingPricePerSegment_gt: BigInt
  pendingPricePerSegment_lt: BigInt
  pendingPricePerSegment_gte: BigInt
  pendingPricePerSegment_lte: BigInt
  pendingPricePerSegment_in: [BigInt!]
  pendingPricePerSegment_not_in: [BigInt!]
  pendingRewardCut: BigInt
  pendingRewardCut_not: BigInt
  pendingRewardCut_gt: BigInt
  pendingRewardCut_lt: BigInt
  pendingRewardCut_gte: BigInt
  pendingRewardCut_lte: BigInt
  pendingRewardCut_in: [BigInt!]
  pendingRewardCut_not_in: [BigInt!]
  pendingFeeShare: BigInt
  pendingFeeShare_not: BigInt
  pendingFeeShare_gt: BigInt
  pendingFeeShare_lt: BigInt
  pendingFeeShare_gte: BigInt
  pendingFeeShare_lte: BigInt
  pendingFeeShare_in: [BigInt!]
  pendingFeeShare_not_in: [BigInt!]
  totalStake: BigDecimal
  totalStake_not: BigDecimal
  totalStake_gt: BigDecimal
  totalStake_lt: BigDecimal
  totalStake_gte: BigDecimal
  totalStake_lte: BigDecimal
  totalStake_in: [BigDecimal!]
  totalStake_not_in: [BigDecimal!]
  totalVolumeETH: BigDecimal
  totalVolumeETH_not: BigDecimal
  totalVolumeETH_gt: BigDecimal
  totalVolumeETH_lt: BigDecimal
  totalVolumeETH_gte: BigDecimal
  totalVolumeETH_lte: BigDecimal
  totalVolumeETH_in: [BigDecimal!]
  totalVolumeETH_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_not_in: [BigDecimal!]
  pools_: Pool_filter
  delegators_: Delegator_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  serviceURI: String
  serviceURI_not: String
  serviceURI_gt: String
  serviceURI_lt: String
  serviceURI_gte: String
  serviceURI_lte: String
  serviceURI_in: [String!]
  serviceURI_not_in: [String!]
  serviceURI_contains: String
  serviceURI_contains_nocase: String
  serviceURI_not_contains: String
  serviceURI_not_contains_nocase: String
  serviceURI_starts_with: String
  serviceURI_starts_with_nocase: String
  serviceURI_not_starts_with: String
  serviceURI_not_starts_with_nocase: String
  serviceURI_ends_with: String
  serviceURI_ends_with_nocase: String
  serviceURI_not_ends_with: String
  serviceURI_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Transcoder_orderBy {
  id
  activationRound
  deactivationRound
  lastActiveStakeUpdateRound
  active
  status
  lastRewardRound
  rewardCut
  feeShare
  pricePerSegment
  pendingPricePerSegment
  pendingRewardCut
  pendingFeeShare
  totalStake
  totalVolumeETH
  totalVolumeUSD
  pools
  delegators
  delegator
  serviceURI
}

"""
UnbondEvent entities are created for every emitted Unbond event.

"""
type UnbondEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Amount unbonded in the transaction"""
  amount: BigDecimal!
  """
  The future round in which the Delegator may withdraw its unbonded stake
  """
  withdrawRound: BigInt!
  """
  The unbonding lock ID associated with this transaction, used to optionally rebond the amount
  """
  unbondingLockId: Int
  """Reference to the delegate unbonded from"""
  delegate: Transcoder!
  """Reference to the Delegator that unbonded"""
  delegator: Delegator!
}

input UnbondEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  withdrawRound: BigInt
  withdrawRound_not: BigInt
  withdrawRound_gt: BigInt
  withdrawRound_lt: BigInt
  withdrawRound_gte: BigInt
  withdrawRound_lte: BigInt
  withdrawRound_in: [BigInt!]
  withdrawRound_not_in: [BigInt!]
  unbondingLockId: Int
  unbondingLockId_not: Int
  unbondingLockId_gt: Int
  unbondingLockId_lt: Int
  unbondingLockId_gte: Int
  unbondingLockId_lte: Int
  unbondingLockId_in: [Int!]
  unbondingLockId_not_in: [Int!]
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum UnbondEvent_orderBy {
  id
  transaction
  timestamp
  round
  amount
  withdrawRound
  unbondingLockId
  delegate
  delegator
}

"""
Get an unbonding lock for a delegator

"""
type UnbondingLock {
  """Unique unlock identifer"""
  id: ID!
  """unbonding lock id"""
  unbondingLockId: Int!
  """Delegator address this lock belongs to"""
  delegator: Delegator!
  """Address of delegate unbonding from"""
  delegate: Transcoder!
  """Amount being unbonded"""
  amount: BigDecimal!
  """
  Round number when the unbonding amount will be available for withdrawal
  """
  withdrawRound: BigInt!
}

input UnbondingLock_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  unbondingLockId: Int
  unbondingLockId_not: Int
  unbondingLockId_gt: Int
  unbondingLockId_lt: Int
  unbondingLockId_gte: Int
  unbondingLockId_lte: Int
  unbondingLockId_in: [Int!]
  unbondingLockId_not_in: [Int!]
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  delegate: String
  delegate_not: String
  delegate_gt: String
  delegate_lt: String
  delegate_gte: String
  delegate_lte: String
  delegate_in: [String!]
  delegate_not_in: [String!]
  delegate_contains: String
  delegate_contains_nocase: String
  delegate_not_contains: String
  delegate_not_contains_nocase: String
  delegate_starts_with: String
  delegate_starts_with_nocase: String
  delegate_not_starts_with: String
  delegate_not_starts_with_nocase: String
  delegate_ends_with: String
  delegate_ends_with_nocase: String
  delegate_not_ends_with: String
  delegate_not_ends_with_nocase: String
  delegate_: Transcoder_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  withdrawRound: BigInt
  withdrawRound_not: BigInt
  withdrawRound_gt: BigInt
  withdrawRound_lt: BigInt
  withdrawRound_gte: BigInt
  withdrawRound_lte: BigInt
  withdrawRound_in: [BigInt!]
  withdrawRound_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum UnbondingLock_orderBy {
  id
  unbondingLockId
  delegator
  delegate
  amount
  withdrawRound
}

"""
UnpauseEvent entities are created for every emitted Unpause event.

"""
type UnpauseEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
}

input UnpauseEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum UnpauseEvent_orderBy {
  id
  transaction
  timestamp
  round
}

"""
Vote data

"""
type Vote {
  """Voter address + poll address"""
  id: ID!
  """Vote caster"""
  voter: String!
  """Stake weighted vote"""
  voteStake: BigDecimal
  """
  This will be non-zero if voter is an transcoder and any of the its delegators voted
  """
  nonVoteStake: BigDecimal
  """Vote choice"""
  choiceID: PollChoice
  """Poll associated with this vote"""
  poll: Poll
  """True if the voter was a registered transcoder during the poll period"""
  registeredTranscoder: Boolean
}

"""
VoteEvent entities are created for every emitted Vote event.

"""
type VoteEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Address belonging to the voter"""
  voter: String!
  """Voter choice. Zero means yes and one means no"""
  choiceID: BigInt!
  """Reference to the poll this vote was casted in"""
  poll: Poll!
}

input VoteEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  voter: String
  voter_not: String
  voter_gt: String
  voter_lt: String
  voter_gte: String
  voter_lte: String
  voter_in: [String!]
  voter_not_in: [String!]
  voter_contains: String
  voter_contains_nocase: String
  voter_not_contains: String
  voter_not_contains_nocase: String
  voter_starts_with: String
  voter_starts_with_nocase: String
  voter_not_starts_with: String
  voter_not_starts_with_nocase: String
  voter_ends_with: String
  voter_ends_with_nocase: String
  voter_not_ends_with: String
  voter_not_ends_with_nocase: String
  choiceID: BigInt
  choiceID_not: BigInt
  choiceID_gt: BigInt
  choiceID_lt: BigInt
  choiceID_gte: BigInt
  choiceID_lte: BigInt
  choiceID_in: [BigInt!]
  choiceID_not_in: [BigInt!]
  poll: String
  poll_not: String
  poll_gt: String
  poll_lt: String
  poll_gte: String
  poll_lte: String
  poll_in: [String!]
  poll_not_in: [String!]
  poll_contains: String
  poll_contains_nocase: String
  poll_not_contains: String
  poll_not_contains_nocase: String
  poll_starts_with: String
  poll_starts_with_nocase: String
  poll_not_starts_with: String
  poll_not_starts_with_nocase: String
  poll_ends_with: String
  poll_ends_with_nocase: String
  poll_not_ends_with: String
  poll_not_ends_with_nocase: String
  poll_: Poll_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum VoteEvent_orderBy {
  id
  transaction
  timestamp
  round
  voter
  choiceID
  poll
}

input Vote_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  voter: String
  voter_not: String
  voter_gt: String
  voter_lt: String
  voter_gte: String
  voter_lte: String
  voter_in: [String!]
  voter_not_in: [String!]
  voter_contains: String
  voter_contains_nocase: String
  voter_not_contains: String
  voter_not_contains_nocase: String
  voter_starts_with: String
  voter_starts_with_nocase: String
  voter_not_starts_with: String
  voter_not_starts_with_nocase: String
  voter_ends_with: String
  voter_ends_with_nocase: String
  voter_not_ends_with: String
  voter_not_ends_with_nocase: String
  voteStake: BigDecimal
  voteStake_not: BigDecimal
  voteStake_gt: BigDecimal
  voteStake_lt: BigDecimal
  voteStake_gte: BigDecimal
  voteStake_lte: BigDecimal
  voteStake_in: [BigDecimal!]
  voteStake_not_in: [BigDecimal!]
  nonVoteStake: BigDecimal
  nonVoteStake_not: BigDecimal
  nonVoteStake_gt: BigDecimal
  nonVoteStake_lt: BigDecimal
  nonVoteStake_gte: BigDecimal
  nonVoteStake_lte: BigDecimal
  nonVoteStake_in: [BigDecimal!]
  nonVoteStake_not_in: [BigDecimal!]
  choiceID: PollChoice
  choiceID_not: PollChoice
  choiceID_in: [PollChoice!]
  choiceID_not_in: [PollChoice!]
  poll: String
  poll_not: String
  poll_gt: String
  poll_lt: String
  poll_gte: String
  poll_lte: String
  poll_in: [String!]
  poll_not_in: [String!]
  poll_contains: String
  poll_contains_nocase: String
  poll_not_contains: String
  poll_not_contains_nocase: String
  poll_starts_with: String
  poll_starts_with_nocase: String
  poll_not_starts_with: String
  poll_not_starts_with_nocase: String
  poll_ends_with: String
  poll_ends_with_nocase: String
  poll_not_ends_with: String
  poll_not_ends_with_nocase: String
  poll_: Poll_filter
  registeredTranscoder: Boolean
  registeredTranscoder_not: Boolean
  registeredTranscoder_in: [Boolean!]
  registeredTranscoder_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Vote_orderBy {
  id
  voter
  voteStake
  nonVoteStake
  choiceID
  poll
  registeredTranscoder
}

"""
WinningTicketRedeemedEvent entities are created for every emitted WinningTicketRedeemed event.

"""
type WinningTicketRedeemedEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the broadcaster who sent the fees"""
  sender: Broadcaster!
  """Reference to the recipient of the broadcaster fees"""
  recipient: Transcoder!
  """Face value of ticket paid to recipient"""
  faceValue: BigDecimal!
  """Amount of fees the winning ticket was redeemed for in in USD"""
  faceValueUSD: BigDecimal!
  """The winning probability of the ticket"""
  winProb: BigInt!
  """Sender's monotonically increasing counter for each ticket"""
  senderNonce: BigInt!
  """keccak256 hash commitment to recipient's random value"""
  recipientRand: BigInt!
  """Auxilary data included in ticket used for additional validation"""
  auxData: Bytes!
}

input WinningTicketRedeemedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Broadcaster_filter
  recipient: String
  recipient_not: String
  recipient_gt: String
  recipient_lt: String
  recipient_gte: String
  recipient_lte: String
  recipient_in: [String!]
  recipient_not_in: [String!]
  recipient_contains: String
  recipient_contains_nocase: String
  recipient_not_contains: String
  recipient_not_contains_nocase: String
  recipient_starts_with: String
  recipient_starts_with_nocase: String
  recipient_not_starts_with: String
  recipient_not_starts_with_nocase: String
  recipient_ends_with: String
  recipient_ends_with_nocase: String
  recipient_not_ends_with: String
  recipient_not_ends_with_nocase: String
  recipient_: Transcoder_filter
  faceValue: BigDecimal
  faceValue_not: BigDecimal
  faceValue_gt: BigDecimal
  faceValue_lt: BigDecimal
  faceValue_gte: BigDecimal
  faceValue_lte: BigDecimal
  faceValue_in: [BigDecimal!]
  faceValue_not_in: [BigDecimal!]
  faceValueUSD: BigDecimal
  faceValueUSD_not: BigDecimal
  faceValueUSD_gt: BigDecimal
  faceValueUSD_lt: BigDecimal
  faceValueUSD_gte: BigDecimal
  faceValueUSD_lte: BigDecimal
  faceValueUSD_in: [BigDecimal!]
  faceValueUSD_not_in: [BigDecimal!]
  winProb: BigInt
  winProb_not: BigInt
  winProb_gt: BigInt
  winProb_lt: BigInt
  winProb_gte: BigInt
  winProb_lte: BigInt
  winProb_in: [BigInt!]
  winProb_not_in: [BigInt!]
  senderNonce: BigInt
  senderNonce_not: BigInt
  senderNonce_gt: BigInt
  senderNonce_lt: BigInt
  senderNonce_gte: BigInt
  senderNonce_lte: BigInt
  senderNonce_in: [BigInt!]
  senderNonce_not_in: [BigInt!]
  recipientRand: BigInt
  recipientRand_not: BigInt
  recipientRand_gt: BigInt
  recipientRand_lt: BigInt
  recipientRand_gte: BigInt
  recipientRand_lte: BigInt
  recipientRand_in: [BigInt!]
  recipientRand_not_in: [BigInt!]
  auxData: Bytes
  auxData_not: Bytes
  auxData_in: [Bytes!]
  auxData_not_in: [Bytes!]
  auxData_contains: Bytes
  auxData_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum WinningTicketRedeemedEvent_orderBy {
  id
  transaction
  timestamp
  round
  sender
  recipient
  faceValue
  faceValueUSD
  winProb
  senderNonce
  recipientRand
  auxData
}

"""
WithdrawFeesEvent entities are created for every emitted WithdrawFees event.

"""
type WithdrawFeesEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegator that withdraw its fees"""
  delegator: Delegator!
  """Amount of fees withdrawn"""
  amount: BigDecimal!
}

input WithdrawFeesEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum WithdrawFeesEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegator
  amount
}

"""
WithdrawStakeEvent entities are created for every emitted WithdrawStake event.

"""
type WithdrawStakeEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the delegator that withdraw its stake"""
  delegator: Delegator!
  """Unbonding lock ID that was deleted upon withdrawal"""
  unbondingLockId: Int
  """Amount of stake withdrawn"""
  amount: BigDecimal!
}

input WithdrawStakeEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  delegator: String
  delegator_not: String
  delegator_gt: String
  delegator_lt: String
  delegator_gte: String
  delegator_lte: String
  delegator_in: [String!]
  delegator_not_in: [String!]
  delegator_contains: String
  delegator_contains_nocase: String
  delegator_not_contains: String
  delegator_not_contains_nocase: String
  delegator_starts_with: String
  delegator_starts_with_nocase: String
  delegator_not_starts_with: String
  delegator_not_starts_with_nocase: String
  delegator_ends_with: String
  delegator_ends_with_nocase: String
  delegator_not_ends_with: String
  delegator_not_ends_with_nocase: String
  delegator_: Delegator_filter
  unbondingLockId: Int
  unbondingLockId_not: Int
  unbondingLockId_gt: Int
  unbondingLockId_lt: Int
  unbondingLockId_gte: Int
  unbondingLockId_lte: Int
  unbondingLockId_in: [Int!]
  unbondingLockId_not_in: [Int!]
  amount: BigDecimal
  amount_not: BigDecimal
  amount_gt: BigDecimal
  amount_lt: BigDecimal
  amount_gte: BigDecimal
  amount_lte: BigDecimal
  amount_in: [BigDecimal!]
  amount_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum WithdrawStakeEvent_orderBy {
  id
  transaction
  timestamp
  round
  delegator
  unbondingLockId
  amount
}

"""
WithdrawalEvent entities are created for every emitted Withdrawal event.

"""
type WithdrawalEvent implements Event {
  """Ethereum transaction hash + event log index"""
  id: ID!
  """Reference to the transaction the event was included in"""
  transaction: Transaction!
  """Timestamp of the transaction the event was included in"""
  timestamp: Int!
  """Reference to the round the event occured in"""
  round: Round!
  """Reference to the broadcaster withdrawing its deposit and reserve"""
  sender: Broadcaster!
  """Deposit amount withdrawn"""
  deposit: BigDecimal!
  """Reserve amount withdrawn"""
  reserve: BigDecimal!
}

input WithdrawalEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  transaction_: Transaction_filter
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  round: String
  round_not: String
  round_gt: String
  round_lt: String
  round_gte: String
  round_lte: String
  round_in: [String!]
  round_not_in: [String!]
  round_contains: String
  round_contains_nocase: String
  round_not_contains: String
  round_not_contains_nocase: String
  round_starts_with: String
  round_starts_with_nocase: String
  round_not_starts_with: String
  round_not_starts_with_nocase: String
  round_ends_with: String
  round_ends_with_nocase: String
  round_not_ends_with: String
  round_not_ends_with_nocase: String
  round_: Round_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Broadcaster_filter
  deposit: BigDecimal
  deposit_not: BigDecimal
  deposit_gt: BigDecimal
  deposit_lt: BigDecimal
  deposit_gte: BigDecimal
  deposit_lte: BigDecimal
  deposit_in: [BigDecimal!]
  deposit_not_in: [BigDecimal!]
  reserve: BigDecimal
  reserve_not: BigDecimal
  reserve_gt: BigDecimal
  reserve_lt: BigDecimal
  reserve_gte: BigDecimal
  reserve_lte: BigDecimal
  reserve_in: [BigDecimal!]
  reserve_not_in: [BigDecimal!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum WithdrawalEvent_orderBy {
  id
  transaction
  timestamp
  round
  sender
  deposit
  reserve
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
  chainName: String!
  subgraphUrl: String!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}